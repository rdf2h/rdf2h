{"version":3,"sources":["webpack:///js/rdf2h.js","webpack:///webpack/bootstrap 62093407d30e63c0d140","webpack:///external \"$rdf\"","webpack:///./src/rdf2h.js","webpack:///./node_modules/rdfgraphnode/js/GraphNode.js","webpack:///external \"fetch\"","webpack:///./node_modules/rdfgraphnode/js/rdfa-processor-dirty-hack.js","webpack:///./node_modules/mustache/mustache.js","webpack:///./src/vocab.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","$rdf","RDF2h","rendererGraph","tbox","console","info","this","env","rdf","GraphNode","Mustache","vocab","Array","origLokup","rdf2h","Context","lookup","view","Renderee","resolvePath","path","resolveSubPath","node","pathSections","subNode","section","endsWith","in","resolveCurie","substring","length","startsWith","out","resultNodes","nodes","language","equals","sym","literal","datatype","slice","string","nextSection","result","push","readingURI","lastCharLess","pos","graphNode","graph","context","splits","split","prefixPart","iriPart","prefix","iri","prefixMap","nodePath","subContext","resolvedNodes","warn","render","map","Error","toString","value","getRenderer","renderee","_this","types","sort","a","b","rdfs","match","localeCompare","concat","t","renderer","getMatching","renderers","find","reduce","type","join","mustache","js","output","print","returnValue","Function","err","message","stackLines","stack","lineWithSelf","findIndex","indexOf","splice","termType","curie","debug","suffix","window","_classCallCheck","instance","Constructor","TypeError","bind","apply","Impl","arguments","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","fetch","RDFaProcessor","Headers","h","_class","sources","_graph","isArray","Promise","resolve","uri","rdfFetch","then","response","f","_this2","results","all","_this3","_this4","predicate","each","statementsMatching","undefined","statement","subject","options","login","ggg","init","headers","set","ok","reject","mediaType","text","DOMParser","log","parseRDFaDOM","Util","parseXML","contentType","error","parse","status","BlankNode","Literal","DataFactory","NamedNode","Uri","Node","ELEMENT_NODE","ATTRIBUTE_NODE","TEXT_NODE","CDATA_SECTION_NODE","ENTITY_REFERENCE_NODE","ENTITY_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","NOTATION_NODE","kb","subjects","prefixes","terms","blankNodes","htmlOptions","selfClosing","theOne","Date","getTime","vocabulary","blankCounter","langAttributes","namespaceURI","localName","inXHTMLMode","absURIRE","finishedHandlers","origin","su","ob","pr","or","namedNode","base","toRDFNodeObject","add","nodeType","parentNode","mappings","newMappings","k","dateTimeTypes","matched","pattern","exec","colon","NCNAME","test","parseCURIE","resolveAndNormalize","defaultVocabulary","ignoreTerms","parseTermOrCURIEOrAbsURI","str","values","tokenize","trim","charAt","parseCURIEOrURI","term","toLowerCase","baseURI","documentElement","setContext","queue","removeHash","hash","baseURIMap","current","item","shift","parent","listMapping","_predicate","list","bnodes","_i","newBlankNode","_i2","addTriple","objectURI","skip","newSubject","currentObjectResource","typedResource","prefixesCopied","incomplete","listMappingDifferent","parseURI","vocabAtt","getAttributeNode","baseSubject","spec","attributes","att","nodeName","copyMappings","ref","prefixAtt","parsePrefixMappings","xmlLangAtt","_i3","getAttributeNodeNS","_value","relAtt","revAtt","typeofAtt","propertyAtt","datatypeAtt","datetimeAtt","inHTMLMode","contentAtt","aboutAtt","srcAtt","resourceAtt","hrefAtt","inlistAtt","relAttPredicates","_i4","parsePredicate","revAttPredicates","_i5","parseSafeCURIEOrCURIEOrURI","parentObject","encodeURI","id","newSubjectOrigin","_i6","typeURI","_i7","_list","_i8","_i9","_i10","_list2","_i11","forward","_i12","content","PlainLiteralURI","XMLLiteralURI","HTMLLiteralURI","textContent","deriveDateTimeType","_i13","_predicate2","_list3","childNodes","_i14","childContext","listSubject","unshift","child","lastChild","previousSibling","copyProperties","_i15","getAttribute","setXHTMLContext","document","doctype","publicId","systemId","setHTMLContext","setXMLContext","setInitialContext","x","keys","forEach","domToString","replace","dom","process","nameChar","nameStartChar","RegExp","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_typeof","Symbol","iterator","obj","constructor","global","factory","isFunction","typeStr","escapeRegExp","hasProperty","propName","testRegExp","re","regExpTest","isWhitespace","nonSpaceRe","escapeHtml","String","entityMap","parseTemplate","template","tags","compileTags","tagsToCompile","spaceRe","openingTagRe","closingTagRe","closingCurlyRe","sections","tokens","spaces","hasTag","nonSpace","start","chr","token","openSection","scanner","Scanner","eos","scanUntil","valueLength","pop","scan","tagRe","whiteRe","equalsRe","curlyRe","nestTokens","squashTokens","lastToken","squashedTokens","numTokens","nestedTokens","collector","tail","parentContext","cache",".","Writer","objectToString","&","<",">","\"","'","/","`","=","index","search","names","lookupHit","clearCache","partials","renderTokens","originalTemplate","symbol","buffer","renderSection","renderInverted","renderPartial","unescapedValue","escapedValue","rawValue","subRender","self","j","escape","version","defaultWriter","to_html","send","schema","foaf"],"mappings":"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","file":"js/rdf2h.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = $rdf;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar rdf = __webpack_require__(0);\nvar GraphNode = __webpack_require__(2);\nvar Mustache = __webpack_require__(5);\nvar vocab = __webpack_require__(6);\nvar NodeSet = new Array();\n\nfunction RDF2h(rendererGraph, tbox) {\n    function r2h(suffix) {\n        return rdf.sym(\"http://rdf2h.github.io/2015/rdf2h#\" + suffix);\n    }\n    console.info(\"RDF2h created\");\n    this.rendererGraph = rendererGraph;\n    if (tbox) {\n        this.tbox = tbox;\n    } else {\n        this.tbox = rendererGraph;\n    }\n    this.env = {}; //this is to allow shared vars among renderers\n}\n\n(function () {\n    var r2h = vocab.rdf2h;\n    var origLokup = Mustache.Context.prototype.lookup;\n    Mustache.Context.prototype.lookup = function (name) {\n        if (this.view instanceof RDF2h.Renderee) {\n            var resolvePath = function resolvePath(path) {\n                function resolveSubPath(node, pathSections) {\n                    function resolveSection(section) {\n                        if (section === \".\") {\n                            return node;\n                        } else {\n                            if (section.endsWith(\"<-\")) {\n                                return node.in(RDF2h.resolveCurie(section.substring(0, section.length - 2)));\n                            } else {\n                                if (section.startsWith(\"^\")) {\n                                    return node.in(RDF2h.resolveCurie(section.substring(1)));\n                                } else {\n                                    return node.out(RDF2h.resolveCurie(section));\n                                }\n                            }\n                        }\n                    }\n                    var subNode = resolveSection(pathSections[0]);\n                    if (pathSections.length === 1) {\n                        var resultNodes = subNode.nodes;\n                        if (resultNodes.length === 0) {\n                            //handling pseudo properties of literals\n                            if (node.nodes[0].language) {\n                                if (RDF2h.resolveCurie(pathSections[0]).equals(rdf.sym(\"http://purl.org/dc/terms/language\"))) {\n                                    return [rdf.literal(node.nodes[0].language)];\n                                }\n                            }\n                            if (node.nodes[0].datatype) {\n                                if (RDF2h.resolveCurie(pathSections[0]).equals(RDF2h.resolveCurie(\"rdf:type\"))) {\n                                    return [node.nodes[0].datatype];\n                                }\n                            }\n                        }\n                        return resultNodes;\n                    }\n                    return resolveSubPath(subNode, pathSections.slice(1));\n                }\n                function splitPathSection(string) {\n                    var result = [];\n                    var readingURI = false;\n                    var lastCharLess = false;\n                    var section = \"\";\n                    function nextSection() {\n                        if (section.length > 0) {\n                            result.push(section);\n                            section = \"\";\n                        }\n                    }\n                    for (var pos = 0; pos < string.length; pos++) {\n                        var c = string[pos];\n                        if (lastCharLess) {\n                            if (c !== \"-\") {\n                                nextSection();\n                                readingURI = true;\n                            }\n                            section += \"<\";\n                            lastCharLess = false;\n                        }\n                        if (c === \"<\") {\n                            lastCharLess = true;\n                            continue;\n                        }\n                        if (readingURI && c == \">\") {\n                            section += c;\n                            nextSection();\n                            readingURI = false;\n                            continue;\n                        }\n                        if (!readingURI && c == \"/\") {\n                            nextSection();\n                            continue;\n                        }\n                        section += c;\n                    }\n                    nextSection();\n                    return result;\n                }\n                var pathSections = splitPathSection(path); // .split(\"/\").filter(function(e) { return e.length > 0})\n                return resolveSubPath(graphNode, pathSections);\n            };\n\n            var rdf2h = this.view.rdf2h;\n            var graphNode = this.view.graphNode;\n            var graph = graphNode.graph;\n            var context = this.view.context;\n\n            if (name.startsWith(\"@prefix \")) {\n                var splits = name.split(\" \");\n                var prefixPart = splits[1];\n                var iriPart = splits[2];\n                var prefix = prefixPart.substring(0, prefixPart.length - 1);\n                var iri = iriPart.substring(1, iriPart.length - 1);\n                RDF2h.prefixMap[prefix] = iri;\n                return \"\";\n            }\n            if (name.startsWith(\":render \")) {\n                var splits = name.split(\" \");\n                var nodePath = splits[1];\n                var subContext = splits[2];\n                if (subContext) {\n                    subContext = RDF2h.resolveCurie(subContext);\n                }\n                if (!subContext) {\n                    subContext = context;\n                }\n                var resolvedNodes = resolvePath(nodePath);\n                if (resolvedNodes.length > 1) {\n                    console.warn(\"Argument of render evaluates to more than one node!\");\n                }\n                if (resolvedNodes.length > 0) {\n                    return rdf2h.render(graph, resolvedNodes[0], subContext);\n                } else {\n                    return \"\";\n                }\n            }\n            if (name.startsWith(\":continue\")) {\n                var splits = name.split(\" \");\n                var subContext = splits[1];\n                if (subContext) {\n                    subContext = RDF2h.resolveCurie(subContext);\n                }\n                if (!subContext) {\n                    subContext = context;\n                }\n                if (graphNode.nodes.length > 1) {\n                    console.warn(\":continue invoked in context with more than one node, this shouldn't be possible!\");\n                }\n                return rdf2h.render(graph, graphNode.nodes[0], subContext);\n            }\n            if (name.startsWith(\"+\")) {\n                name = name.substring(1);\n                return resolvePath(name).length > 0;\n            }\n            var nodes = resolvePath(name);\n            if (nodes.length === 1) {\n                return new RDF2h.Renderee(rdf2h, GraphNode(nodes[0], graph), context);\n            } else {\n                return nodes.map(function (node) {\n                    return new RDF2h.Renderee(rdf2h, GraphNode(node, graph), context);\n                });\n            }\n            /*var node = this.view;\n             if (name === \".\") {\n             return node;\n             } else {\n             return \"not supported: \"+name;\n             }*/\n        } else {\n            return origLokup.call(this, name);\n        }\n    };\n})();\n\nRDF2h.Renderee = function (rdf2h, graphNode, context) {\n    if (!graphNode.nodes) {\n        throw new Error(\"second argument must be a GraphNode\");\n    }\n    if (graphNode.nodes.length !== 1) {\n        throw new Error(\"Renderee must be a single node\");\n    }\n    this.rdf2h = rdf2h;\n    this.graphNode = graphNode;\n    this.context = context;\n};\n\nRDF2h.Renderee.prototype.toString = function () {\n    if (this.graphNode.value) {\n        return this.graphNode.value;\n    }\n    return this.graphNode.toString();\n};\n\nRDF2h.prototype.getRenderer = function (renderee) {\n    var _this = this;\n\n    var r2h = vocab.rdf2h;\n    var tbox = this.tbox;\n    function matchesContext(cfRenderer) {\n        var contexts = cfRenderer.out(r2h(\"context\")).nodes;\n        if (contexts.length === 0) {\n            console.debug(\"renderer \" + cfRenderer + \" specifies no context, thus accepting it for \" + renderee.context);\n            return true;\n        }\n        return contexts.some(function (context) {\n            if (renderee.context.equals(context)) {\n                console.debug(\"renderer \" + cfRenderer + \" matches the context \" + renderee.context);\n                return true;\n            }\n        });\n    }\n    function resolveRendererNode(rendererURI) {\n        if (!window) {\n            return \"Could not get renderer: \" + rendererURI + \", no window object.\";\n        }\n        var pageURIPrefix = window.location + \"#\";\n        if (!rendererURI.startsWith(pageURIPrefix)) {\n            return \"Could not get renderer: \" + rendererURI + \", the prefix must be \" + pageURIPrefix + \".\";\n        }\n        var id = rendererURI.substring(pageURIPrefix.length);\n        return document.getElementById(id).textContent;\n    }\n    function rendererRenderer(renderer) {\n        return function (renderee) {\n            return Mustache.render(renderer, renderee);\n        };\n    }\n    function getTypes(graphNode) {\n        //the array might contain rdfs:Resource twice (at the end)\n        return graphNode.out(vocab.rdf(\"type\")).nodes.sort(function (a, b) {\n            if (a.equals(b)) {\n                return 0;\n            }\n            if (a.equals(vocab.rdfs(\"Resource\"))) {\n                return 1;\n            }\n            if (b.equals(vocab.rdfs(\"Resource\"))) {\n                return -1;\n            }\n            if (tbox.match(a, vocab.rdfs(\"subClassOf\"), b).length === 0) {\n                if (tbox.match(b, vocab.rdfs(\"subClassOf\"), a).length === 0) {\n                    return a.value.localeCompare(b.value);\n                } else {\n                    return 1;\n                }\n            } else {\n                return -1;\n            }\n        }).concat([vocab.rdfs(\"Resource\")]);\n    }\n    function getMatchingRenderer(types, context) {\n        function getMatching(renderers) {\n            return renderers.find(function (renderer) {\n                return context.equals(renderer.out(vocab.rdf2h(\"context\")).node);\n            });\n        }\n        return [false].concat(types).reduce(function (renderer, type) {\n            return renderer ? renderer : getMatching(type.in(vocab.rdf2h(\"type\")).split());\n        });\n    }\n    var types = getTypes(renderee.graphNode).map(function (t) {\n        return GraphNode(t, _this.rendererGraph);\n    });\n    var renderer = getMatchingRenderer(types, renderee.context);\n    if (!renderer) {\n        throw Error(\"No renderer found with context: \" + renderee.context + \" for any of the types \" + types.map(function (t) {\n            return \"<\" + t.value + \">\";\n        }).join() + \". The resource <\" + renderee.graphNode.value + \"> could thus not be rendered.\");\n    }\n    var mustache = renderer.out(vocab.rdf2h(\"mustache\"));\n    if (mustache.nodes.length > 0) {\n        return rendererRenderer(mustache.value);\n    }\n    var js = renderer.out(vocab.rdf2h(\"javaScript\"));\n    return function (renderee) {\n        try {\n            var render = function render(n, context) {\n                return renderee.rdf2h.render(n.graph, n.node, context ? context : renderee.context);\n            };\n            var output = \"\";\n            var print = function print(s) {\n                output += s;\n            };\n            //Also printing return value for now\n            var returnValue = new Function(\"n\", \"context\", \"$rdf\", \"render\", \"print\", \"GraphNode\", \"env\", js.value)(renderee.graphNode, renderee.context, rdf, render, print, GraphNode, renderee.rdf2h.env);\n            if (returnValue) {\n                return output + returnValue;\n            } else {\n                return output;\n            }\n        } catch (err) {\n            err.message = err.message + \" in \" + js.value;\n            var stackLines = err.stack.split(\"\\n\");\n            var lineWithSelf = stackLines.findIndex(function (l) {\n                return l.indexOf(\"RDF2h.render\") > 0;\n            });\n            err.stack = stackLines.splice(0, lineWithSelf - 1).join(\"\\n\");\n            throw err;\n        }\n    };\n};\n\nRDF2h.prototype.render = function (graph, node, context) {\n    if (!node.termType) {\n        node = rdf.sym(node);\n    }\n    if (!context) {\n        context = vocab.rdf2h(\"Default\");\n    }\n    //wrap all in one object that gets special care by lookup\n    var renderee = new RDF2h.Renderee(this, GraphNode(node, graph), context);\n    var renderer = this.getRenderer(renderee);\n    return renderer(renderee);\n};\n\nRDF2h.prefixMap = {};\nRDF2h.prefixMap[\"rdf\"] = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\nRDF2h.prefixMap[\"rdfs\"] = \"http://www.w3.org/2000/01/rdf-schema#\";\nRDF2h.prefixMap[\"r2h\"] = \"http://rdf2h.github.io/2015/rdf2h#\";\nRDF2h.prefixMap[\"schema\"] = \"http://schema.org/\";\nRDF2h.prefixMap[\"rdf\"] = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\nRDF2h.prefixMap[\"dct\"] = \"http://purl.org/dc/terms/\";\n\nRDF2h.resolveCurie = function (curie) {\n    if (curie.startsWith(\"<\") && curie.endsWith(\">\")) {\n        //URI, not a curie\n        return rdf.sym(curie.substring(1, curie.length - 1));\n    }\n    console.debug(\"resolving \" + curie);\n    var splits = curie.split(\":\");\n    var prefix = splits[0];\n    var suffix = splits[1];\n    if (RDF2h.prefixMap[prefix]) {\n        return rdf.sym(RDF2h.prefixMap[prefix] + suffix);\n    } else {\n        return rdf.sym(curie);\n    }\n};\n\nif (typeof window !== 'undefined') {\n    window.RDF2h = RDF2h;\n}\n\nif (true) {\n    module.exports = RDF2h;\n}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar $rdf = __webpack_require__(0);\nvar fetch = __webpack_require__(3);\nvar RDFaProcessor = __webpack_require__(4);\n\n/**\n * Node Status:\n * \n * Locally undetermined: There are multiple local nodes satisfying the criteria specified for this object \n * Blank: The object represents a blank node in a graph that is locally available\n * Unresolved: This node is identified by a URI that has not yet been derefernced\n * \n * @type type\n */\n\nvar Headers = function (h) {\n    return h ? h : window.Headers;\n}(fetch.Headers);\n\nfunction GraphNode() {\n    return new (Function.prototype.bind.apply(GraphNode.Impl, [null].concat(Array.prototype.slice.call(arguments))))();\n}\n\nGraphNode.Impl = function () {\n    function _class(nodes, graph, sources) {\n        _classCallCheck(this, _class);\n\n        this._graph = graph;\n        if (Array.isArray(nodes)) {\n            this.nodes = nodes;\n            /*if (this.nodes.length === 0) {\n                throw \"Can't represent empty set of nodes\";\n            }*/\n        } else {\n            this.nodes = [nodes];\n        }\n        this.sources = sources;\n    }\n\n    _createClass(_class, [{\n        key: \"fetch\",\n        value: function fetch() {\n            var _this = this;\n\n            if (this.termType !== \"NamedNode\" || this.sources && this.sources.indexOf(this.value.split(\"#\")[0]) > -1) {\n                return Promise.resolve(this);\n            } else {\n                //TODO extend existing graph?\n                var uri = this.value.split(\"#\")[0];\n                return GraphNode.rdfFetch(uri).then(function (response) {\n                    return response.graph();\n                }).then(function (graph) {\n                    return GraphNode(_this.node, graph, [uri]);\n                });\n            }\n        }\n\n        /*\n         * \n         * @param {type} f\n         * @returns {unresolved} a promise that is satisfied when all promises returned by f are resolved\n         */\n\n    }, {\n        key: \"each\",\n        value: function each(f) {\n            var _this2 = this;\n\n            var results = this.nodes.map(function (node) {\n                return f(GraphNode([node], _this2.graph, _this2.sources));\n            });\n            return Promise.all(results);\n        }\n    }, {\n        key: \"fetchEach\",\n        value: function fetchEach(f) {\n            var _this3 = this;\n\n            var results = this.nodes.map(function (node) {\n                return GraphNode([node], _this3.graph, _this3.sources).fetch().then(f);\n            });\n            return Promise.all(results);\n        }\n\n        /**\n         * Returns a GraphNode for each node represented by this GraphNode\n         */\n\n    }, {\n        key: \"split\",\n        value: function split() {\n            var _this4 = this;\n\n            return this.nodes.map(function (node) {\n                return GraphNode([node], _this4.graph, _this4.sources);\n            });\n        }\n    }, {\n        key: \"out\",\n        value: function out(predicate) {\n            var nodes = this.graph.each(this.node, predicate);\n            /*if (nodes.length === 0) {\n                throw \"No property \"+predicate+\" on \"+this.node;\n            }*/\n            return GraphNode(nodes, this.graph, this.sources);\n        }\n    }, {\n        key: \"in\",\n        value: function _in(predicate) {\n            var statements = this.graph.statementsMatching(undefined, predicate, this.node);\n            /*if (statements.length === 0) {\n                throw \"No property \"+predicate+\" pointing to \"+this.node;\n            }*/\n            return GraphNode(statements.map(function (statement) {\n                return statement.subject;\n            }), this.graph, this.sources);\n        }\n    }, {\n        key: \"graph\",\n        get: function get() {\n            if (!this._graph) {\n                throw Error(\"Operation not possible as no Graph is available, try fetching first\");\n            }\n            return this._graph;\n        }\n    }, {\n        key: \"node\",\n        get: function get() {\n            if (this.nodes.length !== 1) {\n                throw Error(\"Operation not possible as this GraphNode is underdetermined\");\n            }\n            return this.nodes[0];\n        }\n    }, {\n        key: \"termType\",\n        get: function get() {\n            return this.node.termType;\n        }\n    }, {\n        key: \"value\",\n        get: function get() {\n            ;\n            return this.node.value;\n        }\n    }]);\n\n    return _class;\n}();\n\n/**\n * \n * Fetches an RDF graph. If the server return 401 the login process will be \n * started upon which the fetch will be retried.\n *\n * @param uri {string} The URI to be fetched\n * @param options passed to $rdf.Fetcher\n * @param login {boolean} The login function to be called, optional\n *\n * @return {Promise<Response>} Response has a `graph`property with the rertived graph\n */\nGraphNode.rdfFetch = function (uri, options, login) {\n    function plainFetch(uri) {\n        var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        if (!init.headers) {\n            init.headers = new Headers();\n        }\n        if (!init.headers.get(\"Accept\")) {\n            init.headers.set(\"Accept\", \"text/turtle;q=1, application/n-triples;q=.9, \" + \"application/rdf+xml;q=.8, application/ld+json;q=.7, */*;q=.1\");\n        }\n        return fetch(uri, init).then(function (response) {\n            if (response.ok) {\n                response.graph = function () {\n                    return new Promise(function (resolve, reject) {\n                        var graph = $rdf.graph();\n                        var mediaType = response.headers.get(\"Content-type\").split(\";\")[0];\n                        return response.text().then(function (text) {\n                            if (mediaType === \"text/html\" && typeof DOMParser !== 'undefined') {\n                                console.log(\"Working around rdflib problem parsing RDFa in browser\");\n                                try {\n                                    RDFaProcessor.parseRDFaDOM($rdf.Util.parseXML(text, { contentType: mediaType }), graph, uri);\n                                } catch (error) {\n                                    reject(error);\n                                    return;\n                                }\n                                resolve(graph);\n                            } else {\n                                $rdf.parse(text, graph, uri, mediaType, function (error, graph) {\n                                    if (error) {\n                                        reject(error);\n                                    } else {\n                                        resolve(graph);\n                                    }\n                                });\n                            }\n                        });\n                    });\n                };\n                return response;\n            } else {\n                return response;\n            }\n        });\n    };\n    var ggg = this;\n    return plainFetch(uri, options).then(function (response) {\n        if (response.status < 300) {\n            return response;\n        } else {\n            if (login && response.status === 401) {\n                console.log(\"Got 401 response, attempting to login\");\n                return login().then(function () {\n                    return ggg.rdfFetch(uri, options);\n                });\n            } else {\n                return response;\n            }\n        }\n    });\n};\n\nmodule.exports = GraphNode;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = fetch;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n//The defaut version never worked, this works sometimes\n\n\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n//  RDFa Parser for rdflib.js\n\n// Originally by: Alex Milowski\n// From https://github.com/alexmilowski/green-turtle\n// Converted: timbl 2015-08-25 not yet working\n// Added wrapper: csarven 2016-05-09 working\n\n// RDFaProcessor.prototype = new Object() // Was URIResolver\n\n// RDFaProcessor.prototype.constructor=RDFaProcessor\n\n// options.base = base URI    not really an option, shopuld always be set.\n//\nvar $rdf = __webpack_require__(0);\nvar BlankNode = $rdf.BlankNode;\nvar Literal = $rdf.Literal;\nvar rdf = $rdf.DataFactory;\nvar NamedNode = $rdf.NamedNode;\nvar Uri = $rdf.uri;\nvar Util = $rdf.Util;\n\nif (typeof Node === 'undefined') {\n  //  @@@@@@ Global. Interface to xmldom.\n  var Node = {\n    ELEMENT_NODE: 1,\n    ATTRIBUTE_NODE: 2,\n    TEXT_NODE: 3,\n    CDATA_SECTION_NODE: 4,\n    ENTITY_REFERENCE_NODE: 5,\n    ENTITY_NODE: 6,\n    PROCESSING_INSTRUCTION_NODE: 7,\n    COMMENT_NODE: 8,\n    DOCUMENT_NODE: 9,\n    DOCUMENT_TYPE_NODE: 10,\n    DOCUMENT_FRAGMENT_NODE: 11,\n    NOTATION_NODE: 12\n  };\n}\n\nvar RDFaProcessor = function () {\n  function RDFaProcessor(kb, options) {\n    _classCallCheck(this, RDFaProcessor);\n\n    this.options = options || {};\n    this.kb = kb;\n    this.target = options.target || {\n      graph: {\n        subjects: {},\n        prefixes: {},\n        terms: {}\n        // XXX: Added to track bnodes\n      } };this.blankNodes = [];\n    // XXX: Added for normalisation\n    this.htmlOptions = {\n      'selfClosing': 'br img input area base basefont col colgroup source wbr isindex link meta param hr'\n    };\n    this.theOne = '_:' + new Date().getTime();\n    this.language = null;\n    this.vocabulary = null;\n    this.blankCounter = 0;\n    this.langAttributes = [{ namespaceURI: 'http://www.w3.org/XML/1998/namespace', localName: 'lang' }];\n    this.inXHTMLMode = false;\n    this.absURIRE = /[\\w\\_\\-]+:\\S+/;\n    this.finishedHandlers = [];\n    this.init();\n  }\n\n  _createClass(RDFaProcessor, [{\n    key: 'addTriple',\n    value: function addTriple(origin, subject, predicate, object) {\n      var su, ob, pr, or;\n      if (typeof subject === 'undefined') {\n        su = rdf.namedNode(this.options.base);\n      } else {\n        su = this.toRDFNodeObject(subject);\n      }\n      pr = this.toRDFNodeObject(predicate);\n      ob = this.toRDFNodeObject(object);\n      or = rdf.namedNode(this.options.base);\n      // console.log('Adding { ' + su + ' ' + pr + ' ' + ob + ' ' + or + ' }')\n      this.kb.add(su, pr, ob, or);\n    }\n  }, {\n    key: 'ancestorPath',\n    value: function ancestorPath(node) {\n      var path = '';\n      while (node && node.nodeType !== Node.DOCUMENT_NODE) {\n        path = '/' + node.localName + path;\n        node = node.parentNode;\n      }\n      return path;\n    }\n  }, {\n    key: 'copyMappings',\n    value: function copyMappings(mappings) {\n      var newMappings = {};\n      for (var k in mappings) {\n        newMappings[k] = mappings[k];\n      }\n      return newMappings;\n    }\n  }, {\n    key: 'copyProperties',\n    value: function copyProperties() {}\n  }, {\n    key: 'deriveDateTimeType',\n    value: function deriveDateTimeType(value) {\n      for (var i = 0; i < RDFaProcessor.dateTimeTypes.length; i++) {\n        // console.log(\"Checking \"+value+\" against \"+RDFaProcessor.dateTimeTypes[i].type)\n        var matched = RDFaProcessor.dateTimeTypes[i].pattern.exec(value);\n        if (matched && matched[0].length === value.length) {\n          // console.log(\"Matched!\")\n          return RDFaProcessor.dateTimeTypes[i].type;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: 'init',\n    value: function init() {}\n  }, {\n    key: 'newBlankNode',\n    value: function newBlankNode() {\n      this.blankCounter++;\n      return '_:' + this.blankCounter;\n    }\n  }, {\n    key: 'newSubjectOrigin',\n    value: function newSubjectOrigin(origin, subject) {}\n  }, {\n    key: 'parseCURIE',\n    value: function parseCURIE(value, prefixes, base) {\n      var colon = value.indexOf(':');\n      var uri;\n      if (colon >= 0) {\n        var prefix = value.substring(0, colon);\n        if (prefix === '') {\n          // default prefix\n          uri = prefixes[''];\n          return uri ? uri + value.substring(colon + 1) : null;\n        } else if (prefix === '_') {\n          // blank node\n          return '_:' + value.substring(colon + 1);\n        } else if (RDFaProcessor.NCNAME.test(prefix)) {\n          uri = prefixes[prefix];\n          if (uri) {\n            return uri + value.substring(colon + 1);\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: 'parseCURIEOrURI',\n    value: function parseCURIEOrURI(value, prefixes, base) {\n      var curie = this.parseCURIE(value, prefixes, base);\n      if (curie) {\n        return curie;\n      }\n      return this.resolveAndNormalize(base, value);\n    }\n  }, {\n    key: 'parsePredicate',\n    value: function parsePredicate(value, defaultVocabulary, terms, prefixes, base, ignoreTerms) {\n      if (value === '') {\n        return null;\n      }\n      var predicate = this.parseTermOrCURIEOrAbsURI(value, defaultVocabulary, ignoreTerms ? null : terms, prefixes, base);\n      if (predicate && predicate.indexOf('_:') === 0) {\n        return null;\n      }\n      return predicate;\n    }\n  }, {\n    key: 'parsePrefixMappings',\n    value: function parsePrefixMappings(str, target) {\n      var values = this.tokenize(str);\n      var prefix = null;\n      // var uri = null\n      for (var i = 0; i < values.length; i++) {\n        if (values[i][values[i].length - 1] === ':') {\n          prefix = values[i].substring(0, values[i].length - 1);\n        } else if (prefix) {\n          target[prefix] = this.options.base ? Uri.join(values[i], this.options.base) : values[i];\n          prefix = null;\n        }\n      }\n    }\n  }, {\n    key: 'parseSafeCURIEOrCURIEOrURI',\n    value: function parseSafeCURIEOrCURIEOrURI(value, prefixes, base) {\n      value = this.trim(value);\n      if (value.charAt(0) === '[' && value.charAt(value.length - 1) === ']') {\n        value = value.substring(1, value.length - 1);\n        value = value.trim(value);\n        if (value.length === 0) {\n          return null;\n        }\n        if (value === '_:') {\n          // the one node\n          return this.theOne;\n        }\n        return this.parseCURIE(value, prefixes, base);\n      } else {\n        return this.parseCURIEOrURI(value, prefixes, base);\n      }\n    }\n  }, {\n    key: 'parseTermOrCURIEOrAbsURI',\n    value: function parseTermOrCURIEOrAbsURI(value, defaultVocabulary, terms, prefixes, base) {\n      // alert(\"Parsing \"+value+\" with default vocab \"+defaultVocabulary)\n      value = this.trim(value);\n      var curie = this.parseCURIE(value, prefixes, base);\n      if (curie) {\n        return curie;\n      } else if (terms) {\n        if (defaultVocabulary && !this.absURIRE.exec(value)) {\n          return defaultVocabulary + value;\n        }\n        var term = terms[value];\n        if (term) {\n          return term;\n        }\n        var lcvalue = value.toLowerCase();\n        term = terms[lcvalue];\n        if (term) {\n          return term;\n        }\n      }\n      if (this.absURIRE.exec(value)) {\n        return this.resolveAndNormalize(base, value);\n      }\n      return null;\n    }\n  }, {\n    key: 'parseTermOrCURIEOrURI',\n    value: function parseTermOrCURIEOrURI(value, defaultVocabulary, terms, prefixes, base) {\n      // alert(\"Parsing \"+value+\" with default vocab \"+defaultVocabulary)\n      value = this.trim(value);\n      var curie = this.parseCURIE(value, prefixes, base);\n      if (curie) {\n        return curie;\n      } else {\n        var term = terms[value];\n        if (term) {\n          return term;\n        }\n        var lcvalue = value.toLowerCase();\n        term = terms[lcvalue];\n        if (term) {\n          return term;\n        }\n        if (defaultVocabulary && !this.absURIRE.exec(value)) {\n          return defaultVocabulary + value;\n        }\n      }\n      return this.resolveAndNormalize(base, value);\n    }\n  }, {\n    key: 'parseURI',\n    value: function parseURI(uri) {\n      return uri; // We just use strings as URIs, not objects now.\n    }\n  }, {\n    key: 'process',\n    value: function process(node, options) {\n      /*\r\n      if (!window.console) {\r\n         window.console = { log: function() {} }\r\n      }*/\n      var base;\n      if (node.nodeType === Node.DOCUMENT_NODE) {\n        base = node.baseURI;\n        node = node.documentElement;\n        //node.baseURI = base;\n        this.setContext(node);\n      } else if (node.parentNode.nodeType === Node.DOCUMENT_NODE) {\n        this.setContext(node);\n      }\n      var queue = [];\n      // Fix for Firefox that includes the hash in the base URI\n      var removeHash = function removeHash(baseURI) {\n        // Fix for undefined baseURI property\n        if (!baseURI && options && options.baseURI) {\n          return options.baseURI;\n        }\n\n        var hash = baseURI.indexOf('#');\n        if (hash >= 0) {\n          baseURI = baseURI.substring(0, hash);\n        }\n        if (options && options.baseURIMap) {\n          baseURI = options.baseURIMap(baseURI);\n        }\n        return baseURI;\n      };\n      queue.push({ current: node,\n        context: this.push(null, removeHash(node.baseURI))\n      });\n      while (queue.length > 0) {\n        var item = queue.shift();\n        if (item.parent) {\n          // Sequence Step 14: list triple generation\n          if (item.context.parent && item.context.parent.listMapping === item.listMapping) {\n            // Skip a child context with exactly the same mapping\n            continue;\n          }\n          // console.log(\"Generating lists for \"+item.subject+\", tag \"+item.parent.localName)\n          for (var _predicate in item.listMapping) {\n            var list = item.listMapping[_predicate];\n            if (list.length === 0) {\n              this.addTriple(item.parent, item.subject, _predicate, { type: RDFaProcessor.objectURI, value: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#nil' });\n              continue;\n            }\n            var bnodes = [];\n            for (var _i = 0; _i < list.length; _i++) {\n              bnodes.push(this.newBlankNode());\n              // this.newSubject(item.parent,bnodes[i])\n            }\n            for (var _i2 = 0; _i2 < bnodes.length; _i2++) {\n              this.addTriple(item.parent, bnodes[_i2], 'http://www.w3.org/1999/02/22-rdf-syntax-ns#first', list[_i2]);\n              this.addTriple(item.parent, bnodes[_i2], 'http://www.w3.org/1999/02/22-rdf-syntax-ns#rest', { type: RDFaProcessor.objectURI, value: _i2 + 1 < bnodes.length ? bnodes[_i2 + 1] : 'http://www.w3.org/1999/02/22-rdf-syntax-ns#nil' });\n            }\n            this.addTriple(item.parent, item.subject, _predicate, { type: RDFaProcessor.objectURI, value: bnodes[0] });\n          }\n          continue;\n        }\n        var current = item.current;\n        var context = item.context;\n        // console.log(\"Tag: \"+current.localName+\", listMapping=\"+JSON.stringify(context.listMapping))\n        // Sequence Step 1\n        var skip = false;\n        var newSubject = null;\n        var currentObjectResource = null;\n        var typedResource = null;\n        var prefixes = context.prefixes;\n        var prefixesCopied = false;\n        var incomplete = [];\n        var listMapping = context.listMapping;\n        var listMappingDifferent = !context.parent;\n        var language = context.language;\n        var vocabulary = context.vocabulary;\n        // TODO: the \"base\" element may be used for HTML+RDFa 1.1\n        base = this.parseURI(removeHash(current.baseURI));\n        current.item = null;\n        // Sequence Step 2: set the default vocabulary\n        var vocabAtt = current.getAttributeNode('vocab');\n        if (vocabAtt) {\n          var value = this.trim(vocabAtt.value);\n          if (value.length > 0) {\n            vocabulary = value;\n            var baseSubject = base.spec;\n            // this.newSubject(current,baseSubject)\n            this.addTriple(current, baseSubject, 'http://www.w3.org/ns/rdfa#usesVocabulary', { type: RDFaProcessor.objectURI, value: vocabulary });\n          } else {\n            vocabulary = this.vocabulary;\n          }\n        }\n        // Sequence Step 3: IRI mappings\n        // handle xmlns attributes\n        for (var i = 0; i < current.attributes.length; i++) {\n          var att = current.attributes[i];\n          // if (att.namespaceURI==\"http://www.w3.org/2000/xmlns/\") {\n          if (att.nodeName.charAt(0) === 'x' && att.nodeName.indexOf('xmlns:') === 0) {\n            if (!prefixesCopied) {\n              prefixes = this.copyMappings(prefixes);\n              prefixesCopied = true;\n            }\n            var prefix = att.nodeName.substring(6);\n            // TODO: resolve relative?\n            var ref = this.trim(att.value);\n            prefixes[prefix] = this.options.base ? Uri.join(ref, this.options.base) : ref;\n          }\n        }\n        // Handle prefix mappings (@prefix)\n        var prefixAtt = current.getAttributeNode('prefix');\n        if (prefixAtt) {\n          if (!prefixesCopied) {\n            prefixes = this.copyMappings(prefixes);\n            prefixesCopied = true;\n          }\n          this.parsePrefixMappings(prefixAtt.value, prefixes);\n        }\n        // Sequence Step 4: language\n        var xmlLangAtt = null;\n        for (var _i3 = 0; !xmlLangAtt && _i3 < this.langAttributes.length; _i3++) {\n          xmlLangAtt = current.getAttributeNodeNS(this.langAttributes[_i3].namespaceURI, this.langAttributes[_i3].localName);\n        }\n        if (xmlLangAtt) {\n          var _value = this.trim(xmlLangAtt.value);\n          if (_value.length > 0) {\n            language = _value;\n          } else {\n            language = null;\n          }\n        }\n        var relAtt = current.getAttributeNode('rel');\n        var revAtt = current.getAttributeNode('rev');\n        var typeofAtt = current.getAttributeNode('typeof');\n        var propertyAtt = current.getAttributeNode('property');\n        var datatypeAtt = current.getAttributeNode('datatype');\n        var datetimeAtt = this.inHTMLMode ? current.getAttributeNode('datetime') : null;\n        var contentAtt = current.getAttributeNode('content');\n        var aboutAtt = current.getAttributeNode('about');\n        var srcAtt = current.getAttributeNode('src');\n        var resourceAtt = current.getAttributeNode('resource');\n        var hrefAtt = current.getAttributeNode('href');\n        var inlistAtt = current.getAttributeNode('inlist');\n        var relAttPredicates = [];\n        var predicate, values;\n        if (relAtt) {\n          values = this.tokenize(relAtt.value);\n          for (var _i4 = 0; _i4 < values.length; _i4++) {\n            predicate = this.parsePredicate(values[_i4], vocabulary, context.terms, prefixes, base, this.inHTMLMode && propertyAtt !== null);\n            if (predicate) {\n              relAttPredicates.push(predicate);\n            }\n          }\n        }\n        var revAttPredicates = [];\n        if (revAtt) {\n          values = this.tokenize(revAtt.value);\n          for (var _i5 = 0; _i5 < values.length; _i5++) {\n            predicate = this.parsePredicate(values[_i5], vocabulary, context.terms, prefixes, base, this.inHTMLMode && propertyAtt);\n            if (predicate) {\n              revAttPredicates.push(predicate);\n            }\n          }\n        }\n        // Section 3.1, bullet 7\n        if (this.inHTMLMode && (relAtt || revAtt) && propertyAtt) {\n          if (relAttPredicates.length === 0) {\n            relAtt = null;\n          }\n          if (revAttPredicates.length === 0) {\n            revAtt = null;\n          }\n        }\n        if (relAtt || revAtt) {\n          // Sequence Step 6: establish new subject and value\n          if (aboutAtt) {\n            newSubject = this.parseSafeCURIEOrCURIEOrURI(aboutAtt.value, prefixes, base);\n          }\n          if (typeofAtt) {\n            typedResource = newSubject;\n          }\n          if (!newSubject) {\n            if (current.parentNode.nodeType === Node.DOCUMENT_NODE) {\n              newSubject = removeHash(current.baseURI);\n            } else if (context.parentObject) {\n              // TODO: Verify: If the xml:base has been set and the parentObject is the baseURI of the parent, then the subject needs to be the new base URI\n              newSubject = removeHash(current.parentNode.baseURI) === context.parentObject ? removeHash(current.baseURI) : context.parentObject;\n            }\n          }\n          if (resourceAtt) {\n            currentObjectResource = this.parseSafeCURIEOrCURIEOrURI(resourceAtt.value, prefixes, base);\n          }\n          if (!currentObjectResource) {\n            if (hrefAtt) {\n              currentObjectResource = this.resolveAndNormalize(base, encodeURI(hrefAtt.value));\n            } else if (srcAtt) {\n              currentObjectResource = this.resolveAndNormalize(base, encodeURI(srcAtt.value));\n            } else if (typeofAtt && !aboutAtt && !(this.inXHTMLMode && (current.localName === 'head' || current.localName === 'body'))) {\n              currentObjectResource = this.newBlankNode();\n            }\n          }\n          if (typeofAtt && !aboutAtt && this.inXHTMLMode && (current.localName === 'head' || current.localName === 'body')) {\n            typedResource = newSubject;\n          } else if (typeofAtt && !aboutAtt) {\n            typedResource = currentObjectResource;\n          }\n        } else if (propertyAtt && !contentAtt && !datatypeAtt) {\n          // Sequence Step 5.1: establish a new subject\n          if (aboutAtt) {\n            newSubject = this.parseSafeCURIEOrCURIEOrURI(aboutAtt.value, prefixes, base);\n            if (typeofAtt) {\n              typedResource = newSubject;\n            }\n          }\n          if (!newSubject && current.parentNode.nodeType === Node.DOCUMENT_NODE) {\n            newSubject = removeHash(current.baseURI);\n            if (typeofAtt) {\n              typedResource = newSubject;\n            }\n          } else if (!newSubject && context.parentObject) {\n            // TODO: Verify: If the xml:base has been set and the parentObject is the baseURI of the parent, then the subject needs to be the new base URI\n            newSubject = removeHash(current.parentNode.baseURI) === context.parentObject ? removeHash(current.baseURI) : context.parentObject;\n          }\n          if (typeofAtt && !typedResource) {\n            if (resourceAtt) {\n              typedResource = this.parseSafeCURIEOrCURIEOrURI(resourceAtt.value, prefixes, base);\n            }\n            if (!typedResource && hrefAtt) {\n              typedResource = this.resolveAndNormalize(base, encodeURI(hrefAtt.value));\n            }\n            if (!typedResource && srcAtt) {\n              typedResource = this.resolveAndNormalize(base, encodeURI(srcAtt.value));\n            }\n            if (!typedResource && (this.inXHTMLMode || this.inHTMLMode) && (current.localName === 'head' || current.localName === 'body')) {\n              typedResource = newSubject;\n            }\n            if (!typedResource) {\n              typedResource = this.newBlankNode();\n            }\n            currentObjectResource = typedResource;\n          }\n          // console.log(current.localName+\", newSubject=\"+newSubject+\", typedResource=\"+typedResource+\", currentObjectResource=\"+currentObjectResource)\n        } else {\n          // Sequence Step 5.2: establish a new subject\n          if (aboutAtt) {\n            newSubject = this.parseSafeCURIEOrCURIEOrURI(aboutAtt.value, prefixes, base);\n          }\n          if (!newSubject && resourceAtt) {\n            newSubject = this.parseSafeCURIEOrCURIEOrURI(resourceAtt.value, prefixes, base);\n          }\n          if (!newSubject && hrefAtt) {\n            newSubject = this.resolveAndNormalize(base, encodeURI(hrefAtt.value));\n          }\n          if (!newSubject && srcAtt) {\n            newSubject = this.resolveAndNormalize(base, encodeURI(srcAtt.value));\n          }\n          if (!newSubject) {\n            if (current.parentNode.nodeType === Node.DOCUMENT_NODE) {\n              newSubject = removeHash(current.baseURI);\n            } else if ((this.inXHTMLMode || this.inHTMLMode) && (current.localName === 'head' || current.localName === 'body')) {\n              newSubject = removeHash(current.parentNode.baseURI) === context.parentObject ? removeHash(current.baseURI) : context.parentObject;\n            } else if (typeofAtt) {\n              newSubject = this.newBlankNode();\n            } else if (context.parentObject) {\n              // TODO: Verify: If the xml:base has been set and the parentObject is the baseURI of the parent, then the subject needs to be the new base URI\n              newSubject = removeHash(current.parentNode.baseURI) === context.parentObject ? removeHash(current.baseURI) : context.parentObject;\n              if (!propertyAtt) {\n                skip = true;\n              }\n            }\n          }\n          if (typeofAtt) {\n            typedResource = newSubject;\n          }\n        }\n        // console.log(current.tagName+\": newSubject=\"+newSubject+\", currentObjectResource=\"+currentObjectResource+\", typedResource=\"+typedResource+\", skip=\"+skip)\n        // var rdfaData = null\n        if (newSubject) {\n          // this.newSubject(current,newSubject)\n          if (aboutAtt || resourceAtt || typedResource) {\n            var id = newSubject;\n            if (typeofAtt && !aboutAtt && !resourceAtt && currentObjectResource) {\n              id = currentObjectResource;\n            }\n            // console.log(\"Setting data attribute for \"+current.localName+\" for subject \"+id)\n            this.newSubjectOrigin(current, id);\n          }\n        }\n        // Sequence Step 7: generate type triple\n        if (typedResource) {\n          values = this.tokenize(typeofAtt.value);\n          for (var _i6 = 0; _i6 < values.length; _i6++) {\n            var object = this.parseTermOrCURIEOrAbsURI(values[_i6], vocabulary, context.terms, prefixes, base);\n            if (object) {\n              this.addTriple(current, typedResource, RDFaProcessor.typeURI, { type: RDFaProcessor.objectURI, value: object });\n            }\n          }\n        }\n        // Sequence Step 8: new list mappings if there is a new subject\n        // console.log(\"Step 8: newSubject=\"+newSubject+\", context.parentObject=\"+context.parentObject)\n        if (newSubject && newSubject !== context.parentObject) {\n          // console.log(\"Generating new list mapping for \"+newSubject)\n          listMapping = {};\n          listMappingDifferent = true;\n        }\n        // Sequence Step 9: generate object triple\n        if (currentObjectResource) {\n          if (relAtt && inlistAtt) {\n            for (var _i7 = 0; _i7 < relAttPredicates.length; _i7++) {\n              var _list = listMapping[relAttPredicates[_i7]];\n              if (!_list) {\n                _list = [];\n                listMapping[relAttPredicates[_i7]] = _list;\n              }\n              _list.push({ type: RDFaProcessor.objectURI, value: currentObjectResource });\n            }\n          } else if (relAtt) {\n            for (var _i8 = 0; _i8 < relAttPredicates.length; _i8++) {\n              this.addTriple(current, newSubject, relAttPredicates[_i8], { type: RDFaProcessor.objectURI, value: currentObjectResource });\n            }\n          }\n          if (revAtt) {\n            for (var _i9 = 0; _i9 < revAttPredicates.length; _i9++) {\n              this.addTriple(current, currentObjectResource, revAttPredicates[_i9], { type: RDFaProcessor.objectURI, value: newSubject });\n            }\n          }\n        } else {\n          // Sequence Step 10: incomplete triples\n          if (newSubject && !currentObjectResource && (relAtt || revAtt)) {\n            currentObjectResource = this.newBlankNode();\n            // alert(current.tagName+\": generated blank node, newSubject=\"+newSubject+\" currentObjectResource=\"+currentObjectResource)\n          }\n          if (relAtt && inlistAtt) {\n            for (var _i10 = 0; _i10 < relAttPredicates.length; _i10++) {\n              var _list2 = listMapping[relAttPredicates[_i10]];\n              if (!_list2) {\n                _list2 = [];\n                listMapping[predicate] = _list2;\n              }\n              // console.log(\"Adding incomplete list for \"+predicate)\n              incomplete.push({ predicate: relAttPredicates[_i10], list: _list2 });\n            }\n          } else if (relAtt) {\n            for (var _i11 = 0; _i11 < relAttPredicates.length; _i11++) {\n              incomplete.push({ predicate: relAttPredicates[_i11], forward: true });\n            }\n          }\n          if (revAtt) {\n            for (var _i12 = 0; _i12 < revAttPredicates.length; _i12++) {\n              incomplete.push({ predicate: revAttPredicates[_i12], forward: false });\n            }\n          }\n        }\n        // Step 11: Current property values\n        if (propertyAtt) {\n          var datatype = null;\n          var content = null;\n          if (datatypeAtt) {\n            datatype = datatypeAtt.value === '' ? RDFaProcessor.PlainLiteralURI : this.parseTermOrCURIEOrAbsURI(datatypeAtt.value, vocabulary, context.terms, prefixes, base);\n            if (datetimeAtt && !contentAtt) {\n              content = datetimeAtt.value;\n            } else {\n              content = datatype === RDFaProcessor.XMLLiteralURI || datatype === RDFaProcessor.HTMLLiteralURI ? null : contentAtt ? contentAtt.value : current.textContent;\n            }\n          } else if (contentAtt) {\n            datatype = RDFaProcessor.PlainLiteralURI;\n            content = contentAtt.value;\n          } else if (datetimeAtt) {\n            content = datetimeAtt.value;\n            datatype = RDFaProcessor.deriveDateTimeType(content);\n            if (!datatype) {\n              datatype = RDFaProcessor.PlainLiteralURI;\n            }\n          } else if (!relAtt && !revAtt) {\n            if (resourceAtt) {\n              content = this.parseSafeCURIEOrCURIEOrURI(resourceAtt.value, prefixes, base);\n            }\n            if (!content && hrefAtt) {\n              content = this.resolveAndNormalize(base, encodeURI(hrefAtt.value));\n            } else if (!content && srcAtt) {\n              content = this.resolveAndNormalize(base, encodeURI(srcAtt.value));\n            }\n            if (content) {\n              datatype = RDFaProcessor.objectURI;\n            }\n          }\n          if (!datatype) {\n            if (typeofAtt && !aboutAtt) {\n              datatype = RDFaProcessor.objectURI;\n              content = typedResource;\n            } else {\n              content = current.textContent;\n              if (this.inHTMLMode && current.localName === 'time') {\n                datatype = RDFaProcessor.deriveDateTimeType(content);\n              }\n              if (!datatype) {\n                datatype = RDFaProcessor.PlainLiteralURI;\n              }\n            }\n          }\n          values = this.tokenize(propertyAtt.value);\n          for (var _i13 = 0; _i13 < values.length; _i13++) {\n            var _predicate2 = this.parsePredicate(values[_i13], vocabulary, context.terms, prefixes, base);\n            if (_predicate2) {\n              if (inlistAtt) {\n                var _list3 = listMapping[_predicate2];\n                if (!_list3) {\n                  _list3 = [];\n                  listMapping[_predicate2] = _list3;\n                }\n                _list3.push(datatype === RDFaProcessor.XMLLiteralURI || datatype === RDFaProcessor.HTMLLiteralURI ? { type: datatype, value: current.childNodes } : { type: datatype ? datatype : RDFaProcessor.PlainLiteralURI, value: content, language: language });\n              } else {\n                if (datatype === RDFaProcessor.XMLLiteralURI || datatype === RDFaProcessor.HTMLLiteralURI) {\n                  this.addTriple(current, newSubject, _predicate2, { type: datatype, value: current.childNodes });\n                } else {\n                  this.addTriple(current, newSubject, _predicate2, { type: datatype ? datatype : RDFaProcessor.PlainLiteralURI, value: content, language: language });\n                  // console.log(newSubject+\" \"+predicate+\"=\"+content)\n                }\n              }\n            }\n          }\n        }\n        // Sequence Step 12: complete incomplete triples with new subject\n        if (newSubject && !skip) {\n          for (var _i14 = 0; _i14 < context.incomplete.length; _i14++) {\n            if (context.incomplete[_i14].list) {\n              // console.log(\"Adding subject \"+newSubject+\" to list for \"+context.incomplete[i].predicate)\n              // TODO: it is unclear what to do here\n              context.incomplete[_i14].list.push({ type: RDFaProcessor.objectURI, value: newSubject });\n            } else if (context.incomplete[_i14].forward) {\n              // console.log(current.tagName+\": completing forward triple \"+context.incomplete[i].predicate+\" with object=\"+newSubject)\n              this.addTriple(current, context.subject, context.incomplete[_i14].predicate, { type: RDFaProcessor.objectURI, value: newSubject });\n            } else {\n              // console.log(current.tagName+\": completing reverse triple with object=\"+context.subject)\n              this.addTriple(current, newSubject, context.incomplete[_i14].predicate, { type: RDFaProcessor.objectURI, value: context.subject });\n            }\n          }\n        }\n        var childContext = null;\n        var listSubject = newSubject;\n        if (skip) {\n          // TODO: should subject be null?\n          childContext = this.push(context, context.subject);\n          // TODO: should the entObject be passed along?  If not, then intermediary children will keep properties from being associated with incomplete triples.\n          // TODO: Verify: if the current baseURI has changed and the parentObject is the parent's base URI, then the baseURI should change\n          childContext.parentObject = removeHash(current.parentNode.baseURI) === context.parentObject ? removeHash(current.baseURI) : context.parentObject;\n          childContext.incomplete = context.incomplete;\n          childContext.language = language;\n          childContext.prefixes = prefixes;\n          childContext.vocabulary = vocabulary;\n        } else {\n          childContext = this.push(context, newSubject);\n          childContext.parentObject = currentObjectResource ? currentObjectResource : newSubject ? newSubject : context.subject;\n          childContext.prefixes = prefixes;\n          childContext.incomplete = incomplete;\n          if (currentObjectResource) {\n            // console.log(\"Generating new list mapping for \"+currentObjectResource)\n            listSubject = currentObjectResource;\n            listMapping = {};\n            listMappingDifferent = true;\n          }\n          childContext.listMapping = listMapping;\n          childContext.language = language;\n          childContext.vocabulary = vocabulary;\n        }\n        if (listMappingDifferent) {\n          // console.log(\"Pushing list parent \"+current.localName)\n          queue.unshift({ parent: current, context: context, subject: listSubject, listMapping: listMapping });\n        }\n        for (var child = current.lastChild; child; child = child.previousSibling) {\n          if (child.nodeType === Node.ELEMENT_NODE) {\n            // console.log(\"Pushing child \"+child.localName)\n            //child.baseURI = current.baseURI;\n            queue.unshift({ current: child, context: childContext });\n          }\n        }\n      }\n      if (this.inHTMLMode) {\n        this.copyProperties();\n      }\n      for (var _i15 = 0; _i15 < this.finishedHandlers.length; _i15++) {\n        this.finishedHandlers[_i15](node);\n      }\n    }\n  }, {\n    key: 'push',\n    value: function push(parent, subject) {\n      return {\n        parent: parent,\n        subject: subject ? subject : parent ? parent.subject : null,\n        parentObject: null,\n        incomplete: [],\n        listMapping: parent ? parent.listMapping : {},\n        language: parent ? parent.language : this.language,\n        prefixes: parent ? parent.prefixes : this.target.graph.prefixes,\n        terms: parent ? parent.terms : this.target.graph.terms,\n        vocabulary: parent ? parent.vocabulary : this.vocabulary\n      };\n    }\n  }, {\n    key: 'resolveAndNormalize',\n    value: function resolveAndNormalize(base, uri) {\n      // console.log(\"Joining \" + uri + \" to \" + base + \" making \" +  Uri.join(uri, base))\n      return Uri.join(uri, base); // @@ normalize?\n    }\n  }, {\n    key: 'setContext',\n    value: function setContext(node) {\n      // We only recognized XHTML+RDFa 1.1 if the version is set propertyly\n      if (node.localName === 'html' && node.getAttribute('version') === 'XHTML+RDFa 1.1') {\n        this.setXHTMLContext();\n      } else if (node.localName === 'html' || node.namespaceURI === 'http://www.w3.org/1999/xhtml') {\n        if (typeof document !== 'undefined' && document.doctype) {\n          if (document.doctype.publicId === '-//W3C//DTD XHTML+RDFa 1.0//EN' && document.doctype.systemId === 'http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd') {\n            console.log('WARNING: RDF 1.0 is not supported.  Defaulting to HTML5 mode.');\n            this.setHTMLContext();\n          } else if (document.doctype.publicId === '-//W3C//DTD XHTML+RDFa 1.1//EN' && document.doctype.systemId === 'http://www.w3.org/MarkUp/DTD/xhtml-rdfa-2.dtd') {\n            this.setXHTMLContext();\n          } else {\n            this.setHTMLContext();\n          }\n        } else {\n          this.setHTMLContext();\n        }\n      } else {\n        this.setXMLContext();\n      }\n    }\n  }, {\n    key: 'setHTMLContext',\n    value: function setHTMLContext() {\n      this.setInitialContext();\n      this.langAttributes = [{\n        namespaceURI: 'http://www.w3.org/XML/1998/namespace',\n        localName: 'lang'\n      }, { namespaceURI: null, localName: 'lang' }];\n      this.inXHTMLMode = false;\n      this.inHTMLMode = true;\n    }\n  }, {\n    key: 'setInitialContext',\n    value: function setInitialContext() {\n      this.vocabulary = null;\n      // By default, the prefixes are terms are loaded to the RDFa 1.1. standard within the graph constructor\n      this.langAttributes = [{\n        namespaceURI: 'http://www.w3.org/XML/1998/namespace',\n        localName: 'lang'\n      }];\n    }\n  }, {\n    key: 'setXHTMLContext',\n    value: function setXHTMLContext() {\n      this.setInitialContext();\n      this.inXHTMLMode = true;\n      this.inHTMLMode = false;\n      this.langAttributes = [{\n        namespaceURI: 'http://www.w3.org/XML/1998/namespace',\n        localName: 'lang' }, { namespaceURI: null, localName: 'lang' }];\n      // From http://www.w3.org/2011/rdfa-context/xhtml-rdfa-1.1\n      this.target.graph.terms['alternate'] = 'http://www.w3.org/1999/xhtml/vocab#alternate';\n      this.target.graph.terms['appendix'] = 'http://www.w3.org/1999/xhtml/vocab#appendix';\n      this.target.graph.terms['bookmark'] = 'http://www.w3.org/1999/xhtml/vocab#bookmark';\n      this.target.graph.terms['cite'] = 'http://www.w3.org/1999/xhtml/vocab#cite';\n      this.target.graph.terms['chapter'] = 'http://www.w3.org/1999/xhtml/vocab#chapter';\n      this.target.graph.terms['contents'] = 'http://www.w3.org/1999/xhtml/vocab#contents';\n      this.target.graph.terms['copyright'] = 'http://www.w3.org/1999/xhtml/vocab#copyright';\n      this.target.graph.terms['first'] = 'http://www.w3.org/1999/xhtml/vocab#first';\n      this.target.graph.terms['glossary'] = 'http://www.w3.org/1999/xhtml/vocab#glossary';\n      this.target.graph.terms['help'] = 'http://www.w3.org/1999/xhtml/vocab#help';\n      this.target.graph.terms['icon'] = 'http://www.w3.org/1999/xhtml/vocab#icon';\n      this.target.graph.terms['index'] = 'http://www.w3.org/1999/xhtml/vocab#index';\n      this.target.graph.terms['last'] = 'http://www.w3.org/1999/xhtml/vocab#last';\n      this.target.graph.terms['license'] = 'http://www.w3.org/1999/xhtml/vocab#license';\n      this.target.graph.terms['meta'] = 'http://www.w3.org/1999/xhtml/vocab#meta';\n      this.target.graph.terms['next'] = 'http://www.w3.org/1999/xhtml/vocab#next';\n      this.target.graph.terms['prev'] = 'http://www.w3.org/1999/xhtml/vocab#prev';\n      this.target.graph.terms['previous'] = 'http://www.w3.org/1999/xhtml/vocab#previous';\n      this.target.graph.terms['section'] = 'http://www.w3.org/1999/xhtml/vocab#section';\n      this.target.graph.terms['stylesheet'] = 'http://www.w3.org/1999/xhtml/vocab#stylesheet';\n      this.target.graph.terms['subsection'] = 'http://www.w3.org/1999/xhtml/vocab#subsection';\n      this.target.graph.terms['start'] = 'http://www.w3.org/1999/xhtml/vocab#start';\n      this.target.graph.terms['top'] = 'http://www.w3.org/1999/xhtml/vocab#top';\n      this.target.graph.terms['up'] = 'http://www.w3.org/1999/xhtml/vocab#up';\n      this.target.graph.terms['p3pv1'] = 'http://www.w3.org/1999/xhtml/vocab#p3pv1';\n      // other\n      this.target.graph.terms['related'] = 'http://www.w3.org/1999/xhtml/vocab#related';\n      this.target.graph.terms['role'] = 'http://www.w3.org/1999/xhtml/vocab#role';\n      this.target.graph.terms['transformation'] = 'http://www.w3.org/1999/xhtml/vocab#transformation';\n    }\n  }, {\n    key: 'setXMLContext',\n    value: function setXMLContext() {\n      this.setInitialContext();\n      this.inXHTMLMode = false;\n      this.inHTMLMode = false;\n    }\n  }, {\n    key: 'tokenize',\n    value: function tokenize(str) {\n      return this.trim(str).split(/\\s+/);\n    }\n  }, {\n    key: 'toRDFNodeObject',\n    value: function toRDFNodeObject(x) {\n      if (typeof x === 'undefined') return undefined;\n      if (typeof x === 'string') {\n        if (x.substring(0, 2) === '_:') {\n          if (typeof this.blankNodes[x.substring(2)] === 'undefined') {\n            this.blankNodes[x.substring(2)] = new BlankNode(x.substring(2));\n          }\n          return this.blankNodes[x.substring(2)];\n        }\n        return rdf.namedNode(x);\n      }\n      switch (x.type) {\n        case RDFaProcessor.objectURI:\n          if (x.value.substring(0, 2) === '_:') {\n            if (typeof this.blankNodes[x.value.substring(2)] === 'undefined') {\n              this.blankNodes[x.value.substring(2)] = new BlankNode(x.value.substring(2));\n            }\n            return this.blankNodes[x.value.substring(2)];\n          }\n          return rdf.namedNode(x.value);\n        case RDFaProcessor.PlainLiteralURI:\n          return new Literal(x.value, x.language || '');\n        case RDFaProcessor.XMLLiteralURI:\n        case RDFaProcessor.HTMLLiteralURI:\n          var string = '';\n          Object.keys(x.value).forEach(function (i) {\n            string += Util.domToString(x.value[i], this.htmlOptions);\n          });\n          return new Literal(string, '', new NamedNode(x.type));\n        default:\n          return new Literal(x.value, '', new NamedNode(x.type));\n      }\n    }\n  }, {\n    key: 'trim',\n    value: function trim(str) {\n      return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    }\n  }], [{\n    key: 'parseRDFaDOM',\n    value: function parseRDFaDOM(dom, kb, base) {\n      var p = new RDFaProcessor(kb, { 'base': base });\n      //dom.baseURI = base;\n      p.process(dom);\n    }\n  }]);\n\n  return RDFaProcessor;\n}();\n\nRDFaProcessor.XMLLiteralURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral';\nRDFaProcessor.HTMLLiteralURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#HTML';\nRDFaProcessor.PlainLiteralURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral';\nRDFaProcessor.objectURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#object';\nRDFaProcessor.typeURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type';\nRDFaProcessor.nameChar = \"[-A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u10000-\\uEFFFF.0-9\\xB7\\u0300-\\u036F\\u203F-\\u2040]\";\nRDFaProcessor.nameStartChar = \"[A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\xFF\\u0100-\\u0131\\u0134-\\u013E\\u0141-\\u0148\\u014A-\\u017E\\u0180-\\u01C3\\u01CD-\\u01F0\\u01F4-\\u01F5\\u01FA-\\u0217\\u0250-\\u02A8\\u02BB-\\u02C1\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03CE\\u03D0-\\u03D6\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2-\\u03F3\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E-\\u0481\\u0490-\\u04C4\\u04C7-\\u04C8\\u04CB-\\u04CC\\u04D0-\\u04EB\\u04EE-\\u04F5\\u04F8-\\u04F9\\u0531-\\u0556\\u0559\\u0561-\\u0586\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u063A\\u0641-\\u064A\\u0671-\\u06B7\\u06BA-\\u06BE\\u06C0-\\u06CE\\u06D0-\\u06D3\\u06D5\\u06E5-\\u06E6\\u0905-\\u0939\\u093D\\u0958-\\u0961\\u0985-\\u098C\\u098F-\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09DC-\\u09DD\\u09DF-\\u09E1\\u09F0-\\u09F1\\u0A05-\\u0A0A\\u0A0F-\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32-\\u0A33\\u0A35-\\u0A36\\u0A38-\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8B\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2-\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AE0\\u0B05-\\u0B0C\\u0B0F-\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32-\\u0B33\\u0B36-\\u0B39\\u0B3D\\u0B5C-\\u0B5D\\u0B5F-\\u0B61\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99-\\u0B9A\\u0B9C\\u0B9E-\\u0B9F\\u0BA3-\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB5\\u0BB7-\\u0BB9\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C60-\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CDE\\u0CE0-\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D60-\\u0D61\\u0E01-\\u0E2E\\u0E30\\u0E32-\\u0E33\\u0E40-\\u0E45\\u0E81-\\u0E82\\u0E84\\u0E87-\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA-\\u0EAB\\u0EAD-\\u0EAE\\u0EB0\\u0EB2-\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0F40-\\u0F47\\u0F49-\\u0F69\\u10A0-\\u10C5\\u10D0-\\u10F6\\u1100\\u1102-\\u1103\\u1105-\\u1107\\u1109\\u110B-\\u110C\\u110E-\\u1112\\u113C\\u113E\\u1140\\u114C\\u114E\\u1150\\u1154-\\u1155\\u1159\\u115F-\\u1161\\u1163\\u1165\\u1167\\u1169\\u116D-\\u116E\\u1172-\\u1173\\u1175\\u119E\\u11A8\\u11AB\\u11AE-\\u11AF\\u11B7-\\u11B8\\u11BA\\u11BC-\\u11C2\\u11EB\\u11F0\\u11F9\\u1E00-\\u1E9B\\u1EA0-\\u1EF9\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2126\\u212A-\\u212B\\u212E\\u2180-\\u2182\\u3041-\\u3094\\u30A1-\\u30FA\\u3105-\\u312C\\uAC00-\\uD7A3\\u4E00-\\u9FA5\\u3007\\u3021-\\u3029_]\";\nRDFaProcessor.NCNAME = new RegExp('^' + RDFaProcessor.nameStartChar + RDFaProcessor.nameChar + '*$');\n\n/*\r\nRDFaProcessor.prototype.resolveAndNormalize = function(base,href) {\r\n   var u = base.resolve(href)\r\n   var parsed = this.parseURI(u)\r\n   parsed.normalize()\r\n   return parsed.spec\r\n}\r\n*/\n\nRDFaProcessor.dateTimeTypes = [{ pattern: /-?P(?:[0-9]+Y)?(?:[0-9]+M)?(?:[0-9]+D)?(?:T(?:[0-9]+H)?(?:[0-9]+M)?(?:[0-9]+(?:\\.[0-9]+)?S)?)?/,\n  type: 'http://www.w3.org/2001/XMLSchema#duration' }, { pattern: /-?(?:[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|00[1-9][0-9]|000[1-9])-[0-9][0-9]-[0-9][0-9]T(?:[0-1][0-9]|2[0-4]):[0-5][0-9]:[0-5][0-9](?:\\.[0-9]+)?(?:Z|[+\\-][0-9][0-9]:[0-9][0-9])?/,\n  type: 'http://www.w3.org/2001/XMLSchema#dateTime' }, { pattern: /-?(?:[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|00[1-9][0-9]|000[1-9])-[0-9][0-9]-[0-9][0-9](?:Z|[+\\-][0-9][0-9]:[0-9][0-9])?/,\n  type: 'http://www.w3.org/2001/XMLSchema#date' }, { pattern: /(?:[0-1][0-9]|2[0-4]):[0-5][0-9]:[0-5][0-9](?:\\.[0-9]+)?(?:Z|[+\\-][0-9][0-9]:[0-9][0-9])?/,\n  type: 'http://www.w3.org/2001/XMLSchema#time' }, { pattern: /-?(?:[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|00[1-9][0-9]|000[1-9])-[0-9][0-9]/,\n  type: 'http://www.w3.org/2001/XMLSchema#gYearMonth' }, { pattern: /-?[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|00[1-9][0-9]|000[1-9]/,\n  type: 'http://www.w3.org/2001/XMLSchema#gYear' }];\n\nmodule.exports = RDFaProcessor;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false Mustache: true*/\n\n(function defineMustache(global, factory) {\n  if (( false ? 'undefined' : _typeof(exports)) === 'object' && exports && typeof exports.nodeName !== 'string') {\n    factory(exports); // CommonJS\n  } else if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD\n  } else {\n    global.Mustache = {};\n    factory(global.Mustache); // script, wsh, asp\n  }\n})(undefined, function mustacheFactory(mustache) {\n\n  var objectToString = Object.prototype.toString;\n  var isArray = Array.isArray || function isArrayPolyfill(object) {\n    return objectToString.call(object) === '[object Array]';\n  };\n\n  function isFunction(object) {\n    return typeof object === 'function';\n  }\n\n  /**\n   * More correct typeof string handling array\n   * which normally returns typeof 'object'\n   */\n  function typeStr(obj) {\n    return isArray(obj) ? 'array' : typeof obj === 'undefined' ? 'undefined' : _typeof(obj);\n  }\n\n  function escapeRegExp(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n  }\n\n  /**\n   * Null safe way of checking whether or not an object,\n   * including its prototype, has a given property\n   */\n  function hasProperty(obj, propName) {\n    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && propName in obj;\n  }\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  var regExpTest = RegExp.prototype.test;\n  function testRegExp(re, string) {\n    return regExpTest.call(re, string);\n  }\n\n  var nonSpaceRe = /\\S/;\n  function isWhitespace(string) {\n    return !testRegExp(nonSpaceRe, string);\n  }\n\n  var entityMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n  };\n\n  function escapeHtml(string) {\n    return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap(s) {\n      return entityMap[s];\n    });\n  }\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var equalsRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  /**\n   * Breaks up the given `template` string into a tree of tokens. If the `tags`\n   * argument is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n   * course, the default is to use mustaches (i.e. mustache.tags).\n   *\n   * A token is an array with at least 4 elements. The first element is the\n   * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n   * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n   * all text that appears outside a symbol this element is \"text\".\n   *\n   * The second element of a token is its \"value\". For mustache tags this is\n   * whatever else was inside the tag besides the opening symbol. For text tokens\n   * this is the text itself.\n   *\n   * The third and fourth elements of the token are the start and end indices,\n   * respectively, of the token in the original template.\n   *\n   * Tokens that are the root node of a subtree contain two more elements: 1) an\n   * array of tokens in the subtree and 2) the index in the original template at\n   * which the closing tag for that section begins.\n   */\n  function parseTemplate(template, tags) {\n    if (!template) return [];\n\n    var sections = []; // Stack to hold section tokens\n    var tokens = []; // Buffer to hold the tokens\n    var spaces = []; // Indices of whitespace tokens on the current line\n    var hasTag = false; // Is there a {{tag}} on the current line?\n    var nonSpace = false; // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length) {\n          delete tokens[spaces.pop()];\n        }\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var openingTagRe, closingTagRe, closingCurlyRe;\n    function compileTags(tagsToCompile) {\n      if (typeof tagsToCompile === 'string') tagsToCompile = tagsToCompile.split(spaceRe, 2);\n\n      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2) throw new Error('Invalid tags: ' + tagsToCompile);\n\n      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\n      closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\n      closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\n    }\n\n    compileTags(tags || mustache.tags);\n\n    var scanner = new Scanner(template);\n\n    var start, type, value, chr, token, openSection;\n    while (!scanner.eos()) {\n      start = scanner.pos;\n\n      // Match any text between tags.\n      value = scanner.scanUntil(openingTagRe);\n\n      if (value) {\n        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push(['text', chr, start, start + 1]);\n          start += 1;\n\n          // Check for whitespace on the current line.\n          if (chr === '\\n') stripSpace();\n        }\n      }\n\n      // Match the opening tag.\n      if (!scanner.scan(openingTagRe)) break;\n\n      hasTag = true;\n\n      // Get the tag type.\n      type = scanner.scan(tagRe) || 'name';\n      scanner.scan(whiteRe);\n\n      // Get the tag value.\n      if (type === '=') {\n        value = scanner.scanUntil(equalsRe);\n        scanner.scan(equalsRe);\n        scanner.scanUntil(closingTagRe);\n      } else if (type === '{') {\n        value = scanner.scanUntil(closingCurlyRe);\n        scanner.scan(curlyRe);\n        scanner.scanUntil(closingTagRe);\n        type = '&';\n      } else {\n        value = scanner.scanUntil(closingTagRe);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(closingTagRe)) throw new Error('Unclosed tag at ' + scanner.pos);\n\n      token = [type, value, start, scanner.pos];\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === '/') {\n        // Check section nesting.\n        openSection = sections.pop();\n\n        if (!openSection) throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n        if (openSection[1] !== value) throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n      } else if (type === 'name' || type === '{' || type === '&') {\n        nonSpace = true;\n      } else if (type === '=') {\n        // Set the tags for the next time around.\n        compileTags(value);\n      }\n    }\n\n    // Make sure there are no open sections when we're done.\n    openSection = sections.pop();\n\n    if (openSection) throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n    return nestTokens(squashTokens(tokens));\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens(tokens) {\n    var squashedTokens = [];\n\n    var token, lastToken;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      if (token) {\n        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n          lastToken[1] += token[1];\n          lastToken[3] = token[3];\n        } else {\n          squashedTokens.push(token);\n          lastToken = token;\n        }\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n  function nestTokens(tokens) {\n    var nestedTokens = [];\n    var collector = nestedTokens;\n    var sections = [];\n\n    var token, section;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n        case '#':\n        case '^':\n          collector.push(token);\n          sections.push(token);\n          collector = token[4] = [];\n          break;\n        case '/':\n          section = sections.pop();\n          section[5] = token[2];\n          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n          break;\n        default:\n          collector.push(token);\n      }\n    }\n\n    return nestedTokens;\n  }\n\n  /**\n   * A simple string scanner that is used by the template parser to find\n   * tokens in template strings.\n   */\n  function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function eos() {\n    return this.tail === '';\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function scan(re) {\n    var match = this.tail.match(re);\n\n    if (!match || match.index !== 0) return '';\n\n    var string = match[0];\n\n    this.tail = this.tail.substring(string.length);\n    this.pos += string.length;\n\n    return string;\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function scanUntil(re) {\n    var index = this.tail.search(re),\n        match;\n\n    switch (index) {\n      case -1:\n        match = this.tail;\n        this.tail = '';\n        break;\n      case 0:\n        match = '';\n        break;\n      default:\n        match = this.tail.substring(0, index);\n        this.tail = this.tail.substring(index);\n    }\n\n    this.pos += match.length;\n\n    return match;\n  };\n\n  /**\n   * Represents a rendering context by wrapping a view object and\n   * maintaining a reference to the parent context.\n   */\n  function Context(view, parentContext) {\n    this.view = view;\n    this.cache = { '.': this.view };\n    this.parent = parentContext;\n  }\n\n  /**\n   * Creates a new context using the given view with this context\n   * as the parent.\n   */\n  Context.prototype.push = function push(view) {\n    return new Context(view, this);\n  };\n\n  /**\n   * Returns the value of the given name in this context, traversing\n   * up the context hierarchy if the value is absent in this context's view.\n   */\n  Context.prototype.lookup = function lookup(name) {\n    var cache = this.cache;\n\n    var value;\n    if (cache.hasOwnProperty(name)) {\n      value = cache[name];\n    } else {\n      var context = this,\n          names,\n          index,\n          lookupHit = false;\n\n      while (context) {\n        if (name.indexOf('.') > 0) {\n          value = context.view;\n          names = name.split('.');\n          index = 0;\n\n          /**\n           * Using the dot notion path in `name`, we descend through the\n           * nested objects.\n           *\n           * To be certain that the lookup has been successful, we have to\n           * check if the last object in the path actually has the property\n           * we are looking for. We store the result in `lookupHit`.\n           *\n           * This is specially necessary for when the value has been set to\n           * `undefined` and we want to avoid looking up parent contexts.\n           **/\n          while (value != null && index < names.length) {\n            if (index === names.length - 1) lookupHit = hasProperty(value, names[index]);\n\n            value = value[names[index++]];\n          }\n        } else {\n          value = context.view[name];\n          lookupHit = hasProperty(context.view, name);\n        }\n\n        if (lookupHit) break;\n\n        context = context.parent;\n      }\n\n      cache[name] = value;\n    }\n\n    if (isFunction(value)) value = value.call(this.view);\n\n    return value;\n  };\n\n  /**\n   * A Writer knows how to take a stream of tokens and render them to a\n   * string, given a context. It also maintains a cache of templates to\n   * avoid the need to parse the same template twice.\n   */\n  function Writer() {\n    this.cache = {};\n  }\n\n  /**\n   * Clears all cached templates in this writer.\n   */\n  Writer.prototype.clearCache = function clearCache() {\n    this.cache = {};\n  };\n\n  /**\n   * Parses and caches the given `template` and returns the array of tokens\n   * that is generated from the parse.\n   */\n  Writer.prototype.parse = function parse(template, tags) {\n    var cache = this.cache;\n    var tokens = cache[template];\n\n    if (tokens == null) tokens = cache[template] = parseTemplate(template, tags);\n\n    return tokens;\n  };\n\n  /**\n   * High-level method that is used to render the given `template` with\n   * the given `view`.\n   *\n   * The optional `partials` argument may be an object that contains the\n   * names and templates of partials that are used in the template. It may\n   * also be a function that is used to load partial templates on the fly\n   * that takes a single argument: the name of the partial.\n   */\n  Writer.prototype.render = function render(template, view, partials) {\n    var tokens = this.parse(template);\n    var context = view instanceof Context ? view : new Context(view);\n    return this.renderTokens(tokens, context, partials, template);\n  };\n\n  /**\n   * Low-level method that renders the given array of `tokens` using\n   * the given `context` and `partials`.\n   *\n   * Note: The `originalTemplate` is only ever used to extract the portion\n   * of the original template that was contained in a higher-order section.\n   * If the template doesn't use higher-order sections, this argument may\n   * be omitted.\n   */\n  Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate) {\n    var buffer = '';\n\n    var token, symbol, value;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      value = undefined;\n      token = tokens[i];\n      symbol = token[0];\n\n      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);else if (symbol === '&') value = this.unescapedValue(token, context);else if (symbol === 'name') value = this.escapedValue(token, context);else if (symbol === 'text') value = this.rawValue(token);\n\n      if (value !== undefined) buffer += value;\n    }\n\n    return buffer;\n  };\n\n  Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate) {\n    var self = this;\n    var buffer = '';\n    var value = context.lookup(token[1]);\n\n    // This function is used to render an arbitrary template\n    // in the current context by higher-order sections.\n    function subRender(template) {\n      return self.render(template, context, partials);\n    }\n\n    if (!value) return;\n\n    if (isArray(value)) {\n      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);\n      }\n    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' || typeof value === 'string' || typeof value === 'number') {\n      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);\n    } else if (isFunction(value)) {\n      if (typeof originalTemplate !== 'string') throw new Error('Cannot use higher-order sections without the original template');\n\n      // Extract the portion of the original template that the section contains.\n      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n      if (value != null) buffer += value;\n    } else {\n      buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n    }\n    return buffer;\n  };\n\n  Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate) {\n    var value = context.lookup(token[1]);\n\n    // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n    if (!value || isArray(value) && value.length === 0) return this.renderTokens(token[4], context, partials, originalTemplate);\n  };\n\n  Writer.prototype.renderPartial = function renderPartial(token, context, partials) {\n    if (!partials) return;\n\n    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n    if (value != null) return this.renderTokens(this.parse(value), context, partials, value);\n  };\n\n  Writer.prototype.unescapedValue = function unescapedValue(token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null) return value;\n  };\n\n  Writer.prototype.escapedValue = function escapedValue(token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null) return mustache.escape(value);\n  };\n\n  Writer.prototype.rawValue = function rawValue(token) {\n    return token[1];\n  };\n\n  mustache.name = 'mustache.js';\n  mustache.version = '2.3.0';\n  mustache.tags = ['{{', '}}'];\n\n  // All high-level mustache.* functions use this writer.\n  var defaultWriter = new Writer();\n\n  /**\n   * Clears all cached templates in the default writer.\n   */\n  mustache.clearCache = function clearCache() {\n    return defaultWriter.clearCache();\n  };\n\n  /**\n   * Parses and caches the given template in the default writer and returns the\n   * array of tokens it contains. Doing this ahead of time avoids the need to\n   * parse templates on the fly as they are rendered.\n   */\n  mustache.parse = function parse(template, tags) {\n    return defaultWriter.parse(template, tags);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n  mustache.render = function render(template, view, partials) {\n    if (typeof template !== 'string') {\n      throw new TypeError('Invalid template! Template should be a \"string\" ' + 'but \"' + typeStr(template) + '\" was given as the first ' + 'argument for mustache#render(template, view, partials)');\n    }\n\n    return defaultWriter.render(template, view, partials);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.,\n  /*eslint-disable */ // eslint wants camel cased function name\n  mustache.to_html = function to_html(template, view, partials, send) {\n    /*eslint-enable*/\n\n    var result = mustache.render(template, view, partials);\n\n    if (isFunction(send)) {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  mustache.escape = escapeHtml;\n\n  // Export these mainly for testing, but also for advanced usage.\n  mustache.Scanner = Scanner;\n  mustache.Context = Context;\n  mustache.Writer = Writer;\n\n  return mustache;\n});\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar $rdf = __webpack_require__(0);\n\nmodule.exports = {\n    schema: function schema(suffix) {\n        return $rdf.sym(\"http://schema.org/\" + suffix);\n    },\n    rdf: function rdf(suffix) {\n        return $rdf.sym(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" + suffix);\n    },\n    rdfs: function rdfs(suffix) {\n        return $rdf.sym(\"http://www.w3.org/2000/01/rdf-schema#\" + suffix);\n    },\n    foaf: function foaf(suffix) {\n        return $rdf.sym(\"http://xmlns.com/foaf/0.1/\" + suffix);\n    },\n    rdf2h: function rdf2h(suffix) {\n        return $rdf.sym(\"http://rdf2h.github.io/2015/rdf2h#\" + suffix);\n    }\n};\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// js/rdf2h.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 62093407d30e63c0d140","module.exports = $rdf;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"$rdf\"\n// module id = 0\n// module chunks = 0","var rdf = require(\"rdflib\");\nvar GraphNode = require(\"rdfgraphnode\");\nvar Mustache = require(\"mustache\");\nvar vocab = require(\"./vocab.js\");\nvar NodeSet = new Array();\n\n\nfunction RDF2h(rendererGraph, tbox) {\n    function r2h(suffix) {\n        return rdf.sym(\"http://rdf2h.github.io/2015/rdf2h#\"+suffix);\n    }\n    console.info(\"RDF2h created\");\n    this.rendererGraph = rendererGraph;\n    if (tbox) {\n        this.tbox = tbox;\n    } else {\n        this.tbox = rendererGraph;\n    }\n    this.env = {}; //this is to allow shared vars among renderers\n}\n\n\n(function () {\n    var r2h = vocab.rdf2h;\n    var origLokup = Mustache.Context.prototype.lookup;\n    Mustache.Context.prototype.lookup = function (name) {\n        if (this.view instanceof RDF2h.Renderee) {\n            var rdf2h = this.view.rdf2h;\n            var graphNode = this.view.graphNode;\n            var graph = graphNode.graph;\n            var context = this.view.context;\n            function resolvePath(path) {\n                function resolveSubPath(node, pathSections) {\n                    function resolveSection(section) {\n                        if (section === \".\") {\n                            return node;\n                        } else {\n                            if (section.endsWith(\"<-\")) {\n                                return node.in(RDF2h.resolveCurie(section.substring(0, section.length - 2)));\n                            } else {\n                                if (section.startsWith(\"^\")) {\n                                    return node.in(RDF2h.resolveCurie(section.substring(1)));\n                                } else {\n                                    return node.out(RDF2h.resolveCurie(section));\n                                }\n                            }\n                        }\n                    }\n                    let subNode = resolveSection(pathSections[0]);\n                    if (pathSections.length === 1) {\n                        var resultNodes = subNode.nodes;\n                        if (resultNodes.length === 0) {\n                            //handling pseudo properties of literals\n                            if (node.nodes[0].language) {\n                                if (RDF2h.resolveCurie(pathSections[0]).equals(rdf.sym(\"http://purl.org/dc/terms/language\"))) {\n                                    return [rdf.literal(node.nodes[0].language)];\n                                }\n                            }\n                            if (node.nodes[0].datatype) {\n                                if (RDF2h.resolveCurie(pathSections[0]).equals(RDF2h.resolveCurie(\"rdf:type\"))) {\n                                    return [node.nodes[0].datatype];\n                                }\n                            }\n                        }\n                        return resultNodes;\n                    }\n                    return resolveSubPath(subNode,pathSections.slice(1))    \n                }\n                function splitPathSection(string) {\n                    let result = [];\n                    let readingURI = false;\n                    let lastCharLess = false;\n                    let section = \"\";\n                    function nextSection() {\n                        if (section.length > 0) {\n                            result.push(section);\n                            section = \"\";    \n                        }\n                    }\n                    for (var pos = 0; pos < string.length; pos++) {    \n                        let c = string[pos];\n                        if (lastCharLess) {\n                            if (c !== \"-\") {\n                                nextSection();\n                                readingURI = true;\n                            }\n                            section += \"<\";\n                            lastCharLess = false;\n                        }\n                        if (c === \"<\") {\n                            lastCharLess = true;\n                            continue;\n                        }\n                        if (readingURI && (c == \">\")) {\n                            section += c;\n                            nextSection();\n                            readingURI = false;\n                            continue;\n                        }\n                        if (!readingURI && (c == \"/\")) {\n                            nextSection();\n                            continue;\n                        }\n                        section += c;\n                    }\n                    nextSection();\n                    return result;\n                }\n                var pathSections = splitPathSection(path);// .split(\"/\").filter(function(e) { return e.length > 0})\n                return resolveSubPath(graphNode, pathSections);\n            }\n            if (name.startsWith(\"@prefix \")) {\n                var splits = name.split(\" \");\n                var prefixPart = splits[1];\n                var iriPart = splits[2];\n                var prefix = prefixPart.substring(0, prefixPart.length -1);\n                var iri = iriPart.substring(1, iriPart.length -1);\n                RDF2h.prefixMap[prefix] = iri;\n                return \"\";\n            }\n            if (name.startsWith(\":render \")) {\n                var splits = name.split(\" \");\n                var nodePath = splits[1];\n                var subContext = splits[2];\n                if (subContext) {\n                    subContext = RDF2h.resolveCurie(subContext);\n                }\n                if (!subContext) {\n                    subContext = context;\n                }\n                var resolvedNodes = resolvePath(nodePath);\n                if (resolvedNodes.length > 1) {\n                    console.warn(\"Argument of render evaluates to more than one node!\")\n                }\n                if (resolvedNodes.length > 0) {\n                    return rdf2h.render(graph, resolvedNodes[0], subContext)\n                } else {\n                    return \"\";\n                }\n            }\n            if (name.startsWith(\":continue\")) {\n                var splits = name.split(\" \");\n                var subContext = splits[1];\n                if (subContext) {\n                    subContext = RDF2h.resolveCurie(subContext);\n                }\n                if (!subContext) {\n                    subContext = context;\n                }\n                if (graphNode.nodes.length > 1) {\n                    console.warn(\":continue invoked in context with more than one node, this shouldn't be possible!\")\n                }\n                return rdf2h.render(graph, graphNode.nodes[0], subContext);\n\n            }\n            if (name.startsWith(\"+\")) {\n                name = name.substring(1);\n                return (resolvePath(name).length > 0);\n            }\n            var nodes = resolvePath(name);\n            if (nodes.length === 1) {\n                return new RDF2h.Renderee(rdf2h, GraphNode(nodes[0], graph), context);\n            } else {\n                return nodes.map(function (node) {\n                    return new RDF2h.Renderee(rdf2h, GraphNode(node, graph), context);\n                });\n            }\n            /*var node = this.view;\n             if (name === \".\") {\n             return node;\n             } else {\n             return \"not supported: \"+name;\n             }*/\n        } else {\n            return origLokup.call(this, name);\n        }\n    };\n})();\n\nRDF2h.Renderee = function (rdf2h, graphNode, context) {\n    if (!graphNode.nodes) {\n        throw new Error(\"second argument must be a GraphNode\");\n    }\n    if (graphNode.nodes.length !== 1) {\n        throw new Error(\"Renderee must be a single node\");\n    }\n    this.rdf2h = rdf2h;\n    this.graphNode = graphNode;\n    this.context = context;\n};\n\nRDF2h.Renderee.prototype.toString = function () {\n    if (this.graphNode.value) {\n        return this.graphNode.value;\n    }\n    return this.graphNode.toString();\n}\n\nRDF2h.prototype.getRenderer = function (renderee) {\n    var r2h = vocab.rdf2h;\n    let tbox = this.tbox;\n    function matchesContext(cfRenderer) {\n        var contexts = cfRenderer.out(r2h(\"context\")).nodes;\n        if (contexts.length === 0) {\n            console.debug(\"renderer \"+cfRenderer+\" specifies no context, thus accepting it for \"+renderee.context);\n            return true;\n        }\n        return contexts.some(function(context) {\n            if (renderee.context.equals(context)) {\n                console.debug(\"renderer \"+cfRenderer+\" matches the context \"+renderee.context);\n                return true;\n            }\n        });\n    }\n    function resolveRendererNode(rendererURI) {\n        if (!window) {\n            return \"Could not get renderer: \" + rendererURI + \", no window object.\"\n        }\n        var pageURIPrefix = window.location + \"#\";\n        if (!rendererURI.startsWith(pageURIPrefix)) {\n            return \"Could not get renderer: \" + rendererURI + \", the prefix must be \" + pageURIPrefix + \".\"\n        }\n        var id = rendererURI.substring(pageURIPrefix.length);\n        return document.getElementById(id).textContent;\n    }\n    function rendererRenderer(renderer) {\n        return function (renderee) {\n            return Mustache.render(renderer, renderee);\n        };\n    }\n    function getTypes(graphNode) {\n        //the array might contain rdfs:Resource twice (at the end)\n        return graphNode.out(vocab.rdf(\"type\")).nodes.sort(\n            (a,b) => {\n                if (a.equals(b)) {\n                    return 0;\n                }\n                if (a.equals(vocab.rdfs(\"Resource\"))) {\n                    return 1;\n                }\n                if (b.equals(vocab.rdfs(\"Resource\"))) {\n                    return -1;\n                }\n                if (tbox.match(a, vocab.rdfs(\"subClassOf\"),b).length === 0) {\n                    if (tbox.match(b, vocab.rdfs(\"subClassOf\"),a).length === 0) {\n                        return a.value.localeCompare(b.value);\n                    } else {\n                        return 1;\n                    }\n                } else {\n                    return -1;\n                }\n            }\n        ).concat([vocab.rdfs(\"Resource\")]);\n    }\n    function getMatchingRenderer(types, context) {\n        function getMatching(renderers) {\n            return renderers.find(renderer => context.equals(renderer.out(vocab.rdf2h(\"context\")).node));\n        }\n        return [false].concat(types).reduce((renderer, type) => \n            renderer ? renderer : getMatching(type.in(vocab.rdf2h(\"type\")).split()));\n    }\n    let types = getTypes(renderee.graphNode).map(t => GraphNode(t, this.rendererGraph));\n    let renderer = getMatchingRenderer(types, renderee.context);\n    if (!renderer) {\n        throw Error(\"No renderer found with context: \"+renderee.context+\" for any of the types \"+types.map(t => \"<\"+t.value+\">\").join()\n                    +\". The resource <\"+renderee.graphNode.value+\"> could thus not be rendered.\");\n    }\n    let mustache = renderer.out(vocab.rdf2h(\"mustache\"));\n    if (mustache.nodes.length > 0) {\n        return rendererRenderer(mustache.value);\n    }\n    let js = renderer.out(vocab.rdf2h(\"javaScript\"))\n    return function (renderee) {\n        try {\n            let render =  (n, context) => {\n                return renderee.rdf2h.render(n.graph, n.node, context ? context : renderee.context);\n            };\n            let output = \"\";\n            let print = (s) => {\n                output += s;\n            };\n            //Also printing return value for now\n            let returnValue = (new Function(\"n\", \"context\", \"$rdf\", \"render\", \"print\", \"GraphNode\", \"env\", js.value)\n                    )(renderee.graphNode, renderee.context, rdf, render, print, GraphNode, renderee.rdf2h.env);\n            if (returnValue) {\n                return output + returnValue;\n            } else {\n                return output;\n            }\n        } catch(err) {\n            err.message = err.message + \" in \" + js.value;\n            let stackLines = err.stack.split(\"\\n\");\n            let lineWithSelf = stackLines.findIndex(l => l.indexOf(\"RDF2h.render\") > 0);\n            err.stack = stackLines.splice(0, lineWithSelf - 1).join(\"\\n\");\n            throw err;\n        }\n    };\n\n\n}\n\nRDF2h.prototype.render = function (graph, node, context) {\n    if (!node.termType) {\n        node = rdf.sym(node);\n    }\n    if (!context) {\n        context = vocab.rdf2h(\"Default\");\n    }\n    //wrap all in one object that gets special care by lookup\n    var renderee = new RDF2h.Renderee(this, GraphNode(node, graph), context);\n    var renderer = this.getRenderer(renderee);\n    return renderer(renderee);\n}\n\nRDF2h.prefixMap = {};\nRDF2h.prefixMap[\"rdf\"] = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\nRDF2h.prefixMap[\"rdfs\"] = \"http://www.w3.org/2000/01/rdf-schema#\";\nRDF2h.prefixMap[\"r2h\"] = \"http://rdf2h.github.io/2015/rdf2h#\";\nRDF2h.prefixMap[\"schema\"] = \"http://schema.org/\";\nRDF2h.prefixMap[\"rdf\"] = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\nRDF2h.prefixMap[\"dct\"] = \"http://purl.org/dc/terms/\";\n\n\nRDF2h.resolveCurie = function (curie) {\n    if (curie.startsWith(\"<\") && curie.endsWith(\">\")) {\n        //URI, not a curie\n        return rdf.sym(curie.substring(1, curie.length - 1));\n    }\n    console.debug(\"resolving \" + curie);\n    var splits = curie.split(\":\");\n    var prefix = splits[0];\n    var suffix = splits[1];\n    if (RDF2h.prefixMap[prefix]) {\n        return rdf.sym(RDF2h.prefixMap[prefix] + suffix);\n    } else {\n        return rdf.sym(curie);\n    }\n\n};\n\nif (typeof window !== 'undefined') {\n    window.RDF2h = RDF2h;\n}\n\nif (typeof module !== 'undefined') {\n    module.exports = RDF2h;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/rdf2h.js","var $rdf = require(\"rdflib\");\nvar fetch = require(\"node-fetch\");\nvar RDFaProcessor = require(\"./rdfa-processor-dirty-hack\");\n\n/**\n * Node Status:\n * \n * Locally undetermined: There are multiple local nodes satisfying the criteria specified for this object \n * Blank: The object represents a blank node in a graph that is locally available\n * Unresolved: This node is identified by a URI that has not yet been derefernced\n * \n * @type type\n */\n\nlet Headers = ((h) => h ? h : window.Headers)(fetch.Headers);\n\nfunction GraphNode() {\n    return new GraphNode.Impl(...arguments);\n}\n\nGraphNode.Impl = class {\n        \n        constructor(nodes, graph, sources) {\n            this._graph = graph;\n            if (Array.isArray(nodes)) {\n                this.nodes = nodes;\n                /*if (this.nodes.length === 0) {\n                    throw \"Can't represent empty set of nodes\";\n                }*/\n            } else {\n                this.nodes = [nodes];\n            }\n            this.sources = sources;\n        }\n        \n        get graph() {\n            if (!this._graph) {\n                throw Error(\"Operation not possible as no Graph is available, try fetching first\");\n            }\n            return this._graph;\n        }\n        \n        get node() {\n            if (this.nodes.length !== 1) {\n                throw Error(\"Operation not possible as this GraphNode is underdetermined\");\n            }\n            return this.nodes[0];\n        }\n        \n        get termType() {\n            return this.node.termType;\n        }\n        \n        get value() {;\n            return this.node.value;\n        }\n        \n        fetch() {\n            if ((this.termType !== \"NamedNode\") || \n                        (this.sources && this.sources.indexOf(this.value.split(\"#\")[0]) > -1)) {\n                return Promise.resolve(this);\n            } else {\n                //TODO extend existing graph?\n                var uri = this.value.split(\"#\")[0];\n                return GraphNode.rdfFetch(uri).then(response => response.graph()).then(graph => GraphNode(this.node, graph, [uri]));\n            }\n        }\n        \n        /*\n         * \n         * @param {type} f\n         * @returns {unresolved} a promise that is satisfied when all promises returned by f are resolved\n         */\n        each(f) {\n            var results = this.nodes.map(node => f(GraphNode([node], this.graph, this.sources)));\n            return Promise.all(results);\n        }\n        \n        fetchEach(f) {\n            var results = this.nodes.map(node => GraphNode([node], this.graph, this.sources).fetch().then(f));\n            return Promise.all(results);\n        }\n\n        /**\n         * Returns a GraphNode for each node represented by this GraphNode\n         */\n        split() {\n            return this.nodes.map(node => GraphNode([node], this.graph, this.sources));\n        }\n        \n        out(predicate) {\n            var nodes = this.graph.each(this.node, predicate);\n            /*if (nodes.length === 0) {\n                throw \"No property \"+predicate+\" on \"+this.node;\n            }*/\n            return GraphNode(nodes, this.graph, this.sources);\n        }\n        \n        in(predicate) {\n            var statements = this.graph.statementsMatching(undefined, predicate, this.node);\n            /*if (statements.length === 0) {\n                throw \"No property \"+predicate+\" pointing to \"+this.node;\n            }*/\n            return GraphNode(statements.map(statement => statement.subject), this.graph, this.sources);\n        }\n    }\n\n/**\n * \n * Fetches an RDF graph. If the server return 401 the login process will be \n * started upon which the fetch will be retried.\n *\n * @param uri {string} The URI to be fetched\n * @param options passed to $rdf.Fetcher\n * @param login {boolean} The login function to be called, optional\n *\n * @return {Promise<Response>} Response has a `graph`property with the rertived graph\n */\nGraphNode.rdfFetch = function(uri, options, login) {\n    function plainFetch(uri, init = {}) {\n        if (!init.headers) {\n            init.headers = new Headers();\n        }\n        if (!init.headers.get(\"Accept\")) {\n            init.headers.set(\"Accept\", \"text/turtle;q=1, application/n-triples;q=.9, \"+\n                \"application/rdf+xml;q=.8, application/ld+json;q=.7, */*;q=.1\");\n        }\n        return fetch(uri, init).then(response => {\n            if (response.ok) {\n                response.graph = () => new Promise((resolve, reject) => {\n                    let graph = $rdf.graph();\n                    let mediaType = response.headers.get(\"Content-type\").split(\";\")[0];\n                    return response.text().then(text => {\n                        if ((mediaType === \"text/html\")  && (typeof DOMParser !== 'undefined')) {\n                            console.log(\"Working around rdflib problem parsing RDFa in browser\");\n                            try {\n                                RDFaProcessor.parseRDFaDOM($rdf.Util.parseXML(text, { contentType: mediaType }), graph, uri);\n                            } catch(error) {\n                                reject(error);\n                                return;\n                            }\n                            resolve(graph);\n                        } else {\n                            $rdf.parse(text, graph, uri, mediaType, (error, graph) => {\n                                if (error) {\n                                    reject(error);\n                                } else {\n                                    resolve(graph);\n                                }\n                            });\n                        }\n                    });\n                });\n                return response;\n            } else {\n                return response;\n            }\n        });\n    };\n    var ggg = this;\n    return plainFetch(uri, options).then(function (response) {\n        if (response.status < 300) {\n            return response;\n        } else {\n            if (login && response.status === 401) {\n                console.log(\"Got 401 response, attempting to login\");\n                return login().then(function () {\n                    return ggg.rdfFetch(uri, options);\n                });\n            } else {\n                return response;\n            }\n        }\n    });\n};\n\nmodule.exports = GraphNode;\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/rdfgraphnode/js/GraphNode.js","module.exports = fetch;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fetch\"\n// module id = 3\n// module chunks = 0","//The defaut version never worked, this works sometimes\r\n\r\n'use strict';\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\n//  RDFa Parser for rdflib.js\r\n\r\n// Originally by: Alex Milowski\r\n// From https://github.com/alexmilowski/green-turtle\r\n// Converted: timbl 2015-08-25 not yet working\r\n// Added wrapper: csarven 2016-05-09 working\r\n\r\n// RDFaProcessor.prototype = new Object() // Was URIResolver\r\n\r\n// RDFaProcessor.prototype.constructor=RDFaProcessor\r\n\r\n// options.base = base URI    not really an option, shopuld always be set.\r\n//\r\nvar $rdf = require(\"rdflib\");\r\nvar BlankNode = $rdf.BlankNode;\r\nvar Literal = $rdf.Literal;\r\nvar rdf = $rdf.DataFactory;\r\nvar NamedNode = $rdf.NamedNode;\r\nvar Uri = $rdf.uri;\r\nvar Util = $rdf.Util;\r\n\r\nif (typeof Node === 'undefined') {\r\n  //  @@@@@@ Global. Interface to xmldom.\r\n  var Node = {\r\n    ELEMENT_NODE: 1,\r\n    ATTRIBUTE_NODE: 2,\r\n    TEXT_NODE: 3,\r\n    CDATA_SECTION_NODE: 4,\r\n    ENTITY_REFERENCE_NODE: 5,\r\n    ENTITY_NODE: 6,\r\n    PROCESSING_INSTRUCTION_NODE: 7,\r\n    COMMENT_NODE: 8,\r\n    DOCUMENT_NODE: 9,\r\n    DOCUMENT_TYPE_NODE: 10,\r\n    DOCUMENT_FRAGMENT_NODE: 11,\r\n    NOTATION_NODE: 12\r\n  };\r\n}\r\n\r\nvar RDFaProcessor = function () {\r\n  function RDFaProcessor(kb, options) {\r\n    _classCallCheck(this, RDFaProcessor);\r\n\r\n    this.options = options || {};\r\n    this.kb = kb;\r\n    this.target = options.target || {\r\n      graph: {\r\n        subjects: {},\r\n        prefixes: {},\r\n        terms: {}\r\n      }\r\n      // XXX: Added to track bnodes\r\n    };this.blankNodes = [];\r\n    // XXX: Added for normalisation\r\n    this.htmlOptions = {\r\n      'selfClosing': 'br img input area base basefont col colgroup source wbr isindex link meta param hr'\r\n    };\r\n    this.theOne = '_:' + new Date().getTime();\r\n    this.language = null;\r\n    this.vocabulary = null;\r\n    this.blankCounter = 0;\r\n    this.langAttributes = [{ namespaceURI: 'http://www.w3.org/XML/1998/namespace', localName: 'lang' }];\r\n    this.inXHTMLMode = false;\r\n    this.absURIRE = /[\\w\\_\\-]+:\\S+/;\r\n    this.finishedHandlers = [];\r\n    this.init();\r\n  }\r\n\r\n  _createClass(RDFaProcessor, [{\r\n    key: 'addTriple',\r\n    value: function addTriple(origin, subject, predicate, object) {\r\n      var su, ob, pr, or;\r\n      if (typeof subject === 'undefined') {\r\n        su = rdf.namedNode(this.options.base);\r\n      } else {\r\n        su = this.toRDFNodeObject(subject);\r\n      }\r\n      pr = this.toRDFNodeObject(predicate);\r\n      ob = this.toRDFNodeObject(object);\r\n      or = rdf.namedNode(this.options.base);\r\n      // console.log('Adding { ' + su + ' ' + pr + ' ' + ob + ' ' + or + ' }')\r\n      this.kb.add(su, pr, ob, or);\r\n    }\r\n  }, {\r\n    key: 'ancestorPath',\r\n    value: function ancestorPath(node) {\r\n      var path = '';\r\n      while (node && node.nodeType !== Node.DOCUMENT_NODE) {\r\n        path = '/' + node.localName + path;\r\n        node = node.parentNode;\r\n      }\r\n      return path;\r\n    }\r\n  }, {\r\n    key: 'copyMappings',\r\n    value: function copyMappings(mappings) {\r\n      var newMappings = {};\r\n      for (var k in mappings) {\r\n        newMappings[k] = mappings[k];\r\n      }\r\n      return newMappings;\r\n    }\r\n  }, {\r\n    key: 'copyProperties',\r\n    value: function copyProperties() {}\r\n  }, {\r\n    key: 'deriveDateTimeType',\r\n    value: function deriveDateTimeType(value) {\r\n      for (var i = 0; i < RDFaProcessor.dateTimeTypes.length; i++) {\r\n        // console.log(\"Checking \"+value+\" against \"+RDFaProcessor.dateTimeTypes[i].type)\r\n        var matched = RDFaProcessor.dateTimeTypes[i].pattern.exec(value);\r\n        if (matched && matched[0].length === value.length) {\r\n          // console.log(\"Matched!\")\r\n          return RDFaProcessor.dateTimeTypes[i].type;\r\n        }\r\n      }\r\n      return null;\r\n    }\r\n  }, {\r\n    key: 'init',\r\n    value: function init() {}\r\n  }, {\r\n    key: 'newBlankNode',\r\n    value: function newBlankNode() {\r\n      this.blankCounter++;\r\n      return '_:' + this.blankCounter;\r\n    }\r\n  }, {\r\n    key: 'newSubjectOrigin',\r\n    value: function newSubjectOrigin(origin, subject) {}\r\n  }, {\r\n    key: 'parseCURIE',\r\n    value: function parseCURIE(value, prefixes, base) {\r\n      var colon = value.indexOf(':');\r\n      var uri;\r\n      if (colon >= 0) {\r\n        var prefix = value.substring(0, colon);\r\n        if (prefix === '') {\r\n          // default prefix\r\n          uri = prefixes[''];\r\n          return uri ? uri + value.substring(colon + 1) : null;\r\n        } else if (prefix === '_') {\r\n          // blank node\r\n          return '_:' + value.substring(colon + 1);\r\n        } else if (RDFaProcessor.NCNAME.test(prefix)) {\r\n          uri = prefixes[prefix];\r\n          if (uri) {\r\n            return uri + value.substring(colon + 1);\r\n          }\r\n        }\r\n      }\r\n      return null;\r\n    }\r\n  }, {\r\n    key: 'parseCURIEOrURI',\r\n    value: function parseCURIEOrURI(value, prefixes, base) {\r\n      var curie = this.parseCURIE(value, prefixes, base);\r\n      if (curie) {\r\n        return curie;\r\n      }\r\n      return this.resolveAndNormalize(base, value);\r\n    }\r\n  }, {\r\n    key: 'parsePredicate',\r\n    value: function parsePredicate(value, defaultVocabulary, terms, prefixes, base, ignoreTerms) {\r\n      if (value === '') {\r\n        return null;\r\n      }\r\n      var predicate = this.parseTermOrCURIEOrAbsURI(value, defaultVocabulary, ignoreTerms ? null : terms, prefixes, base);\r\n      if (predicate && predicate.indexOf('_:') === 0) {\r\n        return null;\r\n      }\r\n      return predicate;\r\n    }\r\n  }, {\r\n    key: 'parsePrefixMappings',\r\n    value: function parsePrefixMappings(str, target) {\r\n      var values = this.tokenize(str);\r\n      var prefix = null;\r\n      // var uri = null\r\n      for (var i = 0; i < values.length; i++) {\r\n        if (values[i][values[i].length - 1] === ':') {\r\n          prefix = values[i].substring(0, values[i].length - 1);\r\n        } else if (prefix) {\r\n          target[prefix] = this.options.base ? Uri.join(values[i], this.options.base) : values[i];\r\n          prefix = null;\r\n        }\r\n      }\r\n    }\r\n  }, {\r\n    key: 'parseSafeCURIEOrCURIEOrURI',\r\n    value: function parseSafeCURIEOrCURIEOrURI(value, prefixes, base) {\r\n      value = this.trim(value);\r\n      if (value.charAt(0) === '[' && value.charAt(value.length - 1) === ']') {\r\n        value = value.substring(1, value.length - 1);\r\n        value = value.trim(value);\r\n        if (value.length === 0) {\r\n          return null;\r\n        }\r\n        if (value === '_:') {\r\n          // the one node\r\n          return this.theOne;\r\n        }\r\n        return this.parseCURIE(value, prefixes, base);\r\n      } else {\r\n        return this.parseCURIEOrURI(value, prefixes, base);\r\n      }\r\n    }\r\n  }, {\r\n    key: 'parseTermOrCURIEOrAbsURI',\r\n    value: function parseTermOrCURIEOrAbsURI(value, defaultVocabulary, terms, prefixes, base) {\r\n      // alert(\"Parsing \"+value+\" with default vocab \"+defaultVocabulary)\r\n      value = this.trim(value);\r\n      var curie = this.parseCURIE(value, prefixes, base);\r\n      if (curie) {\r\n        return curie;\r\n      } else if (terms) {\r\n        if (defaultVocabulary && !this.absURIRE.exec(value)) {\r\n          return defaultVocabulary + value;\r\n        }\r\n        var term = terms[value];\r\n        if (term) {\r\n          return term;\r\n        }\r\n        var lcvalue = value.toLowerCase();\r\n        term = terms[lcvalue];\r\n        if (term) {\r\n          return term;\r\n        }\r\n      }\r\n      if (this.absURIRE.exec(value)) {\r\n        return this.resolveAndNormalize(base, value);\r\n      }\r\n      return null;\r\n    }\r\n  }, {\r\n    key: 'parseTermOrCURIEOrURI',\r\n    value: function parseTermOrCURIEOrURI(value, defaultVocabulary, terms, prefixes, base) {\r\n      // alert(\"Parsing \"+value+\" with default vocab \"+defaultVocabulary)\r\n      value = this.trim(value);\r\n      var curie = this.parseCURIE(value, prefixes, base);\r\n      if (curie) {\r\n        return curie;\r\n      } else {\r\n        var term = terms[value];\r\n        if (term) {\r\n          return term;\r\n        }\r\n        var lcvalue = value.toLowerCase();\r\n        term = terms[lcvalue];\r\n        if (term) {\r\n          return term;\r\n        }\r\n        if (defaultVocabulary && !this.absURIRE.exec(value)) {\r\n          return defaultVocabulary + value;\r\n        }\r\n      }\r\n      return this.resolveAndNormalize(base, value);\r\n    }\r\n  }, {\r\n    key: 'parseURI',\r\n    value: function parseURI(uri) {\r\n      return uri; // We just use strings as URIs, not objects now.\r\n    }\r\n  }, {\r\n    key: 'process',\r\n    value: function process(node, options) {\r\n      /*\r\n      if (!window.console) {\r\n         window.console = { log: function() {} }\r\n      }*/\r\n      var base;\r\n      if (node.nodeType === Node.DOCUMENT_NODE) {\r\n        base = node.baseURI;\r\n        node = node.documentElement;\r\n        //node.baseURI = base;\r\n        this.setContext(node);\r\n      } else if (node.parentNode.nodeType === Node.DOCUMENT_NODE) {\r\n        this.setContext(node);\r\n      }\r\n      var queue = [];\r\n      // Fix for Firefox that includes the hash in the base URI\r\n      var removeHash = function removeHash(baseURI) {\r\n        // Fix for undefined baseURI property\r\n        if (!baseURI && options && options.baseURI) {\r\n          return options.baseURI;\r\n        }\r\n\r\n        var hash = baseURI.indexOf('#');\r\n        if (hash >= 0) {\r\n          baseURI = baseURI.substring(0, hash);\r\n        }\r\n        if (options && options.baseURIMap) {\r\n          baseURI = options.baseURIMap(baseURI);\r\n        }\r\n        return baseURI;\r\n      };\r\n      queue.push({ current: node,\r\n        context: this.push(null, removeHash(node.baseURI))\r\n      });\r\n      while (queue.length > 0) {\r\n        var item = queue.shift();\r\n        if (item.parent) {\r\n          // Sequence Step 14: list triple generation\r\n          if (item.context.parent && item.context.parent.listMapping === item.listMapping) {\r\n            // Skip a child context with exactly the same mapping\r\n            continue;\r\n          }\r\n          // console.log(\"Generating lists for \"+item.subject+\", tag \"+item.parent.localName)\r\n          for (var _predicate in item.listMapping) {\r\n            var list = item.listMapping[_predicate];\r\n            if (list.length === 0) {\r\n              this.addTriple(item.parent, item.subject, _predicate, { type: RDFaProcessor.objectURI, value: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#nil' });\r\n              continue;\r\n            }\r\n            var bnodes = [];\r\n            for (var _i = 0; _i < list.length; _i++) {\r\n              bnodes.push(this.newBlankNode());\r\n              // this.newSubject(item.parent,bnodes[i])\r\n            }\r\n            for (var _i2 = 0; _i2 < bnodes.length; _i2++) {\r\n              this.addTriple(item.parent, bnodes[_i2], 'http://www.w3.org/1999/02/22-rdf-syntax-ns#first', list[_i2]);\r\n              this.addTriple(item.parent, bnodes[_i2], 'http://www.w3.org/1999/02/22-rdf-syntax-ns#rest', { type: RDFaProcessor.objectURI, value: _i2 + 1 < bnodes.length ? bnodes[_i2 + 1] : 'http://www.w3.org/1999/02/22-rdf-syntax-ns#nil' });\r\n            }\r\n            this.addTriple(item.parent, item.subject, _predicate, { type: RDFaProcessor.objectURI, value: bnodes[0] });\r\n          }\r\n          continue;\r\n        }\r\n        var current = item.current;\r\n        var context = item.context;\r\n        // console.log(\"Tag: \"+current.localName+\", listMapping=\"+JSON.stringify(context.listMapping))\r\n        // Sequence Step 1\r\n        var skip = false;\r\n        var newSubject = null;\r\n        var currentObjectResource = null;\r\n        var typedResource = null;\r\n        var prefixes = context.prefixes;\r\n        var prefixesCopied = false;\r\n        var incomplete = [];\r\n        var listMapping = context.listMapping;\r\n        var listMappingDifferent = !context.parent;\r\n        var language = context.language;\r\n        var vocabulary = context.vocabulary;\r\n        // TODO: the \"base\" element may be used for HTML+RDFa 1.1\r\n        base = this.parseURI(removeHash(current.baseURI));\r\n        current.item = null;\r\n        // Sequence Step 2: set the default vocabulary\r\n        var vocabAtt = current.getAttributeNode('vocab');\r\n        if (vocabAtt) {\r\n          var value = this.trim(vocabAtt.value);\r\n          if (value.length > 0) {\r\n            vocabulary = value;\r\n            var baseSubject = base.spec;\r\n            // this.newSubject(current,baseSubject)\r\n            this.addTriple(current, baseSubject, 'http://www.w3.org/ns/rdfa#usesVocabulary', { type: RDFaProcessor.objectURI, value: vocabulary });\r\n          } else {\r\n            vocabulary = this.vocabulary;\r\n          }\r\n        }\r\n        // Sequence Step 3: IRI mappings\r\n        // handle xmlns attributes\r\n        for (var i = 0; i < current.attributes.length; i++) {\r\n          var att = current.attributes[i];\r\n          // if (att.namespaceURI==\"http://www.w3.org/2000/xmlns/\") {\r\n          if (att.nodeName.charAt(0) === 'x' && att.nodeName.indexOf('xmlns:') === 0) {\r\n            if (!prefixesCopied) {\r\n              prefixes = this.copyMappings(prefixes);\r\n              prefixesCopied = true;\r\n            }\r\n            var prefix = att.nodeName.substring(6);\r\n            // TODO: resolve relative?\r\n            var ref = this.trim(att.value);\r\n            prefixes[prefix] = this.options.base ? Uri.join(ref, this.options.base) : ref;\r\n          }\r\n        }\r\n        // Handle prefix mappings (@prefix)\r\n        var prefixAtt = current.getAttributeNode('prefix');\r\n        if (prefixAtt) {\r\n          if (!prefixesCopied) {\r\n            prefixes = this.copyMappings(prefixes);\r\n            prefixesCopied = true;\r\n          }\r\n          this.parsePrefixMappings(prefixAtt.value, prefixes);\r\n        }\r\n        // Sequence Step 4: language\r\n        var xmlLangAtt = null;\r\n        for (var _i3 = 0; !xmlLangAtt && _i3 < this.langAttributes.length; _i3++) {\r\n          xmlLangAtt = current.getAttributeNodeNS(this.langAttributes[_i3].namespaceURI, this.langAttributes[_i3].localName);\r\n        }\r\n        if (xmlLangAtt) {\r\n          var _value = this.trim(xmlLangAtt.value);\r\n          if (_value.length > 0) {\r\n            language = _value;\r\n          } else {\r\n            language = null;\r\n          }\r\n        }\r\n        var relAtt = current.getAttributeNode('rel');\r\n        var revAtt = current.getAttributeNode('rev');\r\n        var typeofAtt = current.getAttributeNode('typeof');\r\n        var propertyAtt = current.getAttributeNode('property');\r\n        var datatypeAtt = current.getAttributeNode('datatype');\r\n        var datetimeAtt = this.inHTMLMode ? current.getAttributeNode('datetime') : null;\r\n        var contentAtt = current.getAttributeNode('content');\r\n        var aboutAtt = current.getAttributeNode('about');\r\n        var srcAtt = current.getAttributeNode('src');\r\n        var resourceAtt = current.getAttributeNode('resource');\r\n        var hrefAtt = current.getAttributeNode('href');\r\n        var inlistAtt = current.getAttributeNode('inlist');\r\n        var relAttPredicates = [];\r\n        var predicate, values;\r\n        if (relAtt) {\r\n          values = this.tokenize(relAtt.value);\r\n          for (var _i4 = 0; _i4 < values.length; _i4++) {\r\n            predicate = this.parsePredicate(values[_i4], vocabulary, context.terms, prefixes, base, this.inHTMLMode && propertyAtt !== null);\r\n            if (predicate) {\r\n              relAttPredicates.push(predicate);\r\n            }\r\n          }\r\n        }\r\n        var revAttPredicates = [];\r\n        if (revAtt) {\r\n          values = this.tokenize(revAtt.value);\r\n          for (var _i5 = 0; _i5 < values.length; _i5++) {\r\n            predicate = this.parsePredicate(values[_i5], vocabulary, context.terms, prefixes, base, this.inHTMLMode && propertyAtt);\r\n            if (predicate) {\r\n              revAttPredicates.push(predicate);\r\n            }\r\n          }\r\n        }\r\n        // Section 3.1, bullet 7\r\n        if (this.inHTMLMode && (relAtt || revAtt) && propertyAtt) {\r\n          if (relAttPredicates.length === 0) {\r\n            relAtt = null;\r\n          }\r\n          if (revAttPredicates.length === 0) {\r\n            revAtt = null;\r\n          }\r\n        }\r\n        if (relAtt || revAtt) {\r\n          // Sequence Step 6: establish new subject and value\r\n          if (aboutAtt) {\r\n            newSubject = this.parseSafeCURIEOrCURIEOrURI(aboutAtt.value, prefixes, base);\r\n          }\r\n          if (typeofAtt) {\r\n            typedResource = newSubject;\r\n          }\r\n          if (!newSubject) {\r\n            if (current.parentNode.nodeType === Node.DOCUMENT_NODE) {\r\n              newSubject = removeHash(current.baseURI);\r\n            } else if (context.parentObject) {\r\n              // TODO: Verify: If the xml:base has been set and the parentObject is the baseURI of the parent, then the subject needs to be the new base URI\r\n              newSubject = removeHash(current.parentNode.baseURI) === context.parentObject ? removeHash(current.baseURI) : context.parentObject;\r\n            }\r\n          }\r\n          if (resourceAtt) {\r\n            currentObjectResource = this.parseSafeCURIEOrCURIEOrURI(resourceAtt.value, prefixes, base);\r\n          }\r\n          if (!currentObjectResource) {\r\n            if (hrefAtt) {\r\n              currentObjectResource = this.resolveAndNormalize(base, encodeURI(hrefAtt.value));\r\n            } else if (srcAtt) {\r\n              currentObjectResource = this.resolveAndNormalize(base, encodeURI(srcAtt.value));\r\n            } else if (typeofAtt && !aboutAtt && !(this.inXHTMLMode && (current.localName === 'head' || current.localName === 'body'))) {\r\n              currentObjectResource = this.newBlankNode();\r\n            }\r\n          }\r\n          if (typeofAtt && !aboutAtt && this.inXHTMLMode && (current.localName === 'head' || current.localName === 'body')) {\r\n            typedResource = newSubject;\r\n          } else if (typeofAtt && !aboutAtt) {\r\n            typedResource = currentObjectResource;\r\n          }\r\n        } else if (propertyAtt && !contentAtt && !datatypeAtt) {\r\n          // Sequence Step 5.1: establish a new subject\r\n          if (aboutAtt) {\r\n            newSubject = this.parseSafeCURIEOrCURIEOrURI(aboutAtt.value, prefixes, base);\r\n            if (typeofAtt) {\r\n              typedResource = newSubject;\r\n            }\r\n          }\r\n          if (!newSubject && current.parentNode.nodeType === Node.DOCUMENT_NODE) {\r\n            newSubject = removeHash(current.baseURI);\r\n            if (typeofAtt) {\r\n              typedResource = newSubject;\r\n            }\r\n          } else if (!newSubject && context.parentObject) {\r\n            // TODO: Verify: If the xml:base has been set and the parentObject is the baseURI of the parent, then the subject needs to be the new base URI\r\n            newSubject = removeHash(current.parentNode.baseURI) === context.parentObject ? removeHash(current.baseURI) : context.parentObject;\r\n          }\r\n          if (typeofAtt && !typedResource) {\r\n            if (resourceAtt) {\r\n              typedResource = this.parseSafeCURIEOrCURIEOrURI(resourceAtt.value, prefixes, base);\r\n            }\r\n            if (!typedResource && hrefAtt) {\r\n              typedResource = this.resolveAndNormalize(base, encodeURI(hrefAtt.value));\r\n            }\r\n            if (!typedResource && srcAtt) {\r\n              typedResource = this.resolveAndNormalize(base, encodeURI(srcAtt.value));\r\n            }\r\n            if (!typedResource && (this.inXHTMLMode || this.inHTMLMode) && (current.localName === 'head' || current.localName === 'body')) {\r\n              typedResource = newSubject;\r\n            }\r\n            if (!typedResource) {\r\n              typedResource = this.newBlankNode();\r\n            }\r\n            currentObjectResource = typedResource;\r\n          }\r\n          // console.log(current.localName+\", newSubject=\"+newSubject+\", typedResource=\"+typedResource+\", currentObjectResource=\"+currentObjectResource)\r\n        } else {\r\n          // Sequence Step 5.2: establish a new subject\r\n          if (aboutAtt) {\r\n            newSubject = this.parseSafeCURIEOrCURIEOrURI(aboutAtt.value, prefixes, base);\r\n          }\r\n          if (!newSubject && resourceAtt) {\r\n            newSubject = this.parseSafeCURIEOrCURIEOrURI(resourceAtt.value, prefixes, base);\r\n          }\r\n          if (!newSubject && hrefAtt) {\r\n            newSubject = this.resolveAndNormalize(base, encodeURI(hrefAtt.value));\r\n          }\r\n          if (!newSubject && srcAtt) {\r\n            newSubject = this.resolveAndNormalize(base, encodeURI(srcAtt.value));\r\n          }\r\n          if (!newSubject) {\r\n            if (current.parentNode.nodeType === Node.DOCUMENT_NODE) {\r\n              newSubject = removeHash(current.baseURI);\r\n            } else if ((this.inXHTMLMode || this.inHTMLMode) && (current.localName === 'head' || current.localName === 'body')) {\r\n              newSubject = removeHash(current.parentNode.baseURI) === context.parentObject ? removeHash(current.baseURI) : context.parentObject;\r\n            } else if (typeofAtt) {\r\n              newSubject = this.newBlankNode();\r\n            } else if (context.parentObject) {\r\n              // TODO: Verify: If the xml:base has been set and the parentObject is the baseURI of the parent, then the subject needs to be the new base URI\r\n              newSubject = removeHash(current.parentNode.baseURI) === context.parentObject ? removeHash(current.baseURI) : context.parentObject;\r\n              if (!propertyAtt) {\r\n                skip = true;\r\n              }\r\n            }\r\n          }\r\n          if (typeofAtt) {\r\n            typedResource = newSubject;\r\n          }\r\n        }\r\n        // console.log(current.tagName+\": newSubject=\"+newSubject+\", currentObjectResource=\"+currentObjectResource+\", typedResource=\"+typedResource+\", skip=\"+skip)\r\n        // var rdfaData = null\r\n        if (newSubject) {\r\n          // this.newSubject(current,newSubject)\r\n          if (aboutAtt || resourceAtt || typedResource) {\r\n            var id = newSubject;\r\n            if (typeofAtt && !aboutAtt && !resourceAtt && currentObjectResource) {\r\n              id = currentObjectResource;\r\n            }\r\n            // console.log(\"Setting data attribute for \"+current.localName+\" for subject \"+id)\r\n            this.newSubjectOrigin(current, id);\r\n          }\r\n        }\r\n        // Sequence Step 7: generate type triple\r\n        if (typedResource) {\r\n          values = this.tokenize(typeofAtt.value);\r\n          for (var _i6 = 0; _i6 < values.length; _i6++) {\r\n            var object = this.parseTermOrCURIEOrAbsURI(values[_i6], vocabulary, context.terms, prefixes, base);\r\n            if (object) {\r\n              this.addTriple(current, typedResource, RDFaProcessor.typeURI, { type: RDFaProcessor.objectURI, value: object });\r\n            }\r\n          }\r\n        }\r\n        // Sequence Step 8: new list mappings if there is a new subject\r\n        // console.log(\"Step 8: newSubject=\"+newSubject+\", context.parentObject=\"+context.parentObject)\r\n        if (newSubject && newSubject !== context.parentObject) {\r\n          // console.log(\"Generating new list mapping for \"+newSubject)\r\n          listMapping = {};\r\n          listMappingDifferent = true;\r\n        }\r\n        // Sequence Step 9: generate object triple\r\n        if (currentObjectResource) {\r\n          if (relAtt && inlistAtt) {\r\n            for (var _i7 = 0; _i7 < relAttPredicates.length; _i7++) {\r\n              var _list = listMapping[relAttPredicates[_i7]];\r\n              if (!_list) {\r\n                _list = [];\r\n                listMapping[relAttPredicates[_i7]] = _list;\r\n              }\r\n              _list.push({ type: RDFaProcessor.objectURI, value: currentObjectResource });\r\n            }\r\n          } else if (relAtt) {\r\n            for (var _i8 = 0; _i8 < relAttPredicates.length; _i8++) {\r\n              this.addTriple(current, newSubject, relAttPredicates[_i8], { type: RDFaProcessor.objectURI, value: currentObjectResource });\r\n            }\r\n          }\r\n          if (revAtt) {\r\n            for (var _i9 = 0; _i9 < revAttPredicates.length; _i9++) {\r\n              this.addTriple(current, currentObjectResource, revAttPredicates[_i9], { type: RDFaProcessor.objectURI, value: newSubject });\r\n            }\r\n          }\r\n        } else {\r\n          // Sequence Step 10: incomplete triples\r\n          if (newSubject && !currentObjectResource && (relAtt || revAtt)) {\r\n            currentObjectResource = this.newBlankNode();\r\n            // alert(current.tagName+\": generated blank node, newSubject=\"+newSubject+\" currentObjectResource=\"+currentObjectResource)\r\n          }\r\n          if (relAtt && inlistAtt) {\r\n            for (var _i10 = 0; _i10 < relAttPredicates.length; _i10++) {\r\n              var _list2 = listMapping[relAttPredicates[_i10]];\r\n              if (!_list2) {\r\n                _list2 = [];\r\n                listMapping[predicate] = _list2;\r\n              }\r\n              // console.log(\"Adding incomplete list for \"+predicate)\r\n              incomplete.push({ predicate: relAttPredicates[_i10], list: _list2 });\r\n            }\r\n          } else if (relAtt) {\r\n            for (var _i11 = 0; _i11 < relAttPredicates.length; _i11++) {\r\n              incomplete.push({ predicate: relAttPredicates[_i11], forward: true });\r\n            }\r\n          }\r\n          if (revAtt) {\r\n            for (var _i12 = 0; _i12 < revAttPredicates.length; _i12++) {\r\n              incomplete.push({ predicate: revAttPredicates[_i12], forward: false });\r\n            }\r\n          }\r\n        }\r\n        // Step 11: Current property values\r\n        if (propertyAtt) {\r\n          var datatype = null;\r\n          var content = null;\r\n          if (datatypeAtt) {\r\n            datatype = datatypeAtt.value === '' ? RDFaProcessor.PlainLiteralURI : this.parseTermOrCURIEOrAbsURI(datatypeAtt.value, vocabulary, context.terms, prefixes, base);\r\n            if (datetimeAtt && !contentAtt) {\r\n              content = datetimeAtt.value;\r\n            } else {\r\n              content = datatype === RDFaProcessor.XMLLiteralURI || datatype === RDFaProcessor.HTMLLiteralURI ? null : contentAtt ? contentAtt.value : current.textContent;\r\n            }\r\n          } else if (contentAtt) {\r\n            datatype = RDFaProcessor.PlainLiteralURI;\r\n            content = contentAtt.value;\r\n          } else if (datetimeAtt) {\r\n            content = datetimeAtt.value;\r\n            datatype = RDFaProcessor.deriveDateTimeType(content);\r\n            if (!datatype) {\r\n              datatype = RDFaProcessor.PlainLiteralURI;\r\n            }\r\n          } else if (!relAtt && !revAtt) {\r\n            if (resourceAtt) {\r\n              content = this.parseSafeCURIEOrCURIEOrURI(resourceAtt.value, prefixes, base);\r\n            }\r\n            if (!content && hrefAtt) {\r\n              content = this.resolveAndNormalize(base, encodeURI(hrefAtt.value));\r\n            } else if (!content && srcAtt) {\r\n              content = this.resolveAndNormalize(base, encodeURI(srcAtt.value));\r\n            }\r\n            if (content) {\r\n              datatype = RDFaProcessor.objectURI;\r\n            }\r\n          }\r\n          if (!datatype) {\r\n            if (typeofAtt && !aboutAtt) {\r\n              datatype = RDFaProcessor.objectURI;\r\n              content = typedResource;\r\n            } else {\r\n              content = current.textContent;\r\n              if (this.inHTMLMode && current.localName === 'time') {\r\n                datatype = RDFaProcessor.deriveDateTimeType(content);\r\n              }\r\n              if (!datatype) {\r\n                datatype = RDFaProcessor.PlainLiteralURI;\r\n              }\r\n            }\r\n          }\r\n          values = this.tokenize(propertyAtt.value);\r\n          for (var _i13 = 0; _i13 < values.length; _i13++) {\r\n            var _predicate2 = this.parsePredicate(values[_i13], vocabulary, context.terms, prefixes, base);\r\n            if (_predicate2) {\r\n              if (inlistAtt) {\r\n                var _list3 = listMapping[_predicate2];\r\n                if (!_list3) {\r\n                  _list3 = [];\r\n                  listMapping[_predicate2] = _list3;\r\n                }\r\n                _list3.push(datatype === RDFaProcessor.XMLLiteralURI || datatype === RDFaProcessor.HTMLLiteralURI ? { type: datatype, value: current.childNodes } : { type: datatype ? datatype : RDFaProcessor.PlainLiteralURI, value: content, language: language });\r\n              } else {\r\n                if (datatype === RDFaProcessor.XMLLiteralURI || datatype === RDFaProcessor.HTMLLiteralURI) {\r\n                  this.addTriple(current, newSubject, _predicate2, { type: datatype, value: current.childNodes });\r\n                } else {\r\n                  this.addTriple(current, newSubject, _predicate2, { type: datatype ? datatype : RDFaProcessor.PlainLiteralURI, value: content, language: language });\r\n                  // console.log(newSubject+\" \"+predicate+\"=\"+content)\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        // Sequence Step 12: complete incomplete triples with new subject\r\n        if (newSubject && !skip) {\r\n          for (var _i14 = 0; _i14 < context.incomplete.length; _i14++) {\r\n            if (context.incomplete[_i14].list) {\r\n              // console.log(\"Adding subject \"+newSubject+\" to list for \"+context.incomplete[i].predicate)\r\n              // TODO: it is unclear what to do here\r\n              context.incomplete[_i14].list.push({ type: RDFaProcessor.objectURI, value: newSubject });\r\n            } else if (context.incomplete[_i14].forward) {\r\n              // console.log(current.tagName+\": completing forward triple \"+context.incomplete[i].predicate+\" with object=\"+newSubject)\r\n              this.addTriple(current, context.subject, context.incomplete[_i14].predicate, { type: RDFaProcessor.objectURI, value: newSubject });\r\n            } else {\r\n              // console.log(current.tagName+\": completing reverse triple with object=\"+context.subject)\r\n              this.addTriple(current, newSubject, context.incomplete[_i14].predicate, { type: RDFaProcessor.objectURI, value: context.subject });\r\n            }\r\n          }\r\n        }\r\n        var childContext = null;\r\n        var listSubject = newSubject;\r\n        if (skip) {\r\n          // TODO: should subject be null?\r\n          childContext = this.push(context, context.subject);\r\n          // TODO: should the entObject be passed along?  If not, then intermediary children will keep properties from being associated with incomplete triples.\r\n          // TODO: Verify: if the current baseURI has changed and the parentObject is the parent's base URI, then the baseURI should change\r\n          childContext.parentObject = removeHash(current.parentNode.baseURI) === context.parentObject ? removeHash(current.baseURI) : context.parentObject;\r\n          childContext.incomplete = context.incomplete;\r\n          childContext.language = language;\r\n          childContext.prefixes = prefixes;\r\n          childContext.vocabulary = vocabulary;\r\n        } else {\r\n          childContext = this.push(context, newSubject);\r\n          childContext.parentObject = currentObjectResource ? currentObjectResource : newSubject ? newSubject : context.subject;\r\n          childContext.prefixes = prefixes;\r\n          childContext.incomplete = incomplete;\r\n          if (currentObjectResource) {\r\n            // console.log(\"Generating new list mapping for \"+currentObjectResource)\r\n            listSubject = currentObjectResource;\r\n            listMapping = {};\r\n            listMappingDifferent = true;\r\n          }\r\n          childContext.listMapping = listMapping;\r\n          childContext.language = language;\r\n          childContext.vocabulary = vocabulary;\r\n        }\r\n        if (listMappingDifferent) {\r\n          // console.log(\"Pushing list parent \"+current.localName)\r\n          queue.unshift({ parent: current, context: context, subject: listSubject, listMapping: listMapping });\r\n        }\r\n        for (var child = current.lastChild; child; child = child.previousSibling) {\r\n          if (child.nodeType === Node.ELEMENT_NODE) {\r\n            // console.log(\"Pushing child \"+child.localName)\r\n            //child.baseURI = current.baseURI;\r\n            queue.unshift({ current: child, context: childContext });\r\n          }\r\n        }\r\n      }\r\n      if (this.inHTMLMode) {\r\n        this.copyProperties();\r\n      }\r\n      for (var _i15 = 0; _i15 < this.finishedHandlers.length; _i15++) {\r\n        this.finishedHandlers[_i15](node);\r\n      }\r\n    }\r\n  }, {\r\n    key: 'push',\r\n    value: function push(parent, subject) {\r\n      return {\r\n        parent: parent,\r\n        subject: subject ? subject : parent ? parent.subject : null,\r\n        parentObject: null,\r\n        incomplete: [],\r\n        listMapping: parent ? parent.listMapping : {},\r\n        language: parent ? parent.language : this.language,\r\n        prefixes: parent ? parent.prefixes : this.target.graph.prefixes,\r\n        terms: parent ? parent.terms : this.target.graph.terms,\r\n        vocabulary: parent ? parent.vocabulary : this.vocabulary\r\n      };\r\n    }\r\n  }, {\r\n    key: 'resolveAndNormalize',\r\n    value: function resolveAndNormalize(base, uri) {\r\n      // console.log(\"Joining \" + uri + \" to \" + base + \" making \" +  Uri.join(uri, base))\r\n      return Uri.join(uri, base); // @@ normalize?\r\n    }\r\n  }, {\r\n    key: 'setContext',\r\n    value: function setContext(node) {\r\n      // We only recognized XHTML+RDFa 1.1 if the version is set propertyly\r\n      if (node.localName === 'html' && node.getAttribute('version') === 'XHTML+RDFa 1.1') {\r\n        this.setXHTMLContext();\r\n      } else if (node.localName === 'html' || node.namespaceURI === 'http://www.w3.org/1999/xhtml') {\r\n        if (typeof document !== 'undefined' && document.doctype) {\r\n          if (document.doctype.publicId === '-//W3C//DTD XHTML+RDFa 1.0//EN' && document.doctype.systemId === 'http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd') {\r\n            console.log('WARNING: RDF 1.0 is not supported.  Defaulting to HTML5 mode.');\r\n            this.setHTMLContext();\r\n          } else if (document.doctype.publicId === '-//W3C//DTD XHTML+RDFa 1.1//EN' && document.doctype.systemId === 'http://www.w3.org/MarkUp/DTD/xhtml-rdfa-2.dtd') {\r\n            this.setXHTMLContext();\r\n          } else {\r\n            this.setHTMLContext();\r\n          }\r\n        } else {\r\n          this.setHTMLContext();\r\n        }\r\n      } else {\r\n        this.setXMLContext();\r\n      }\r\n    }\r\n  }, {\r\n    key: 'setHTMLContext',\r\n    value: function setHTMLContext() {\r\n      this.setInitialContext();\r\n      this.langAttributes = [{\r\n        namespaceURI: 'http://www.w3.org/XML/1998/namespace',\r\n        localName: 'lang'\r\n      }, { namespaceURI: null, localName: 'lang' }];\r\n      this.inXHTMLMode = false;\r\n      this.inHTMLMode = true;\r\n    }\r\n  }, {\r\n    key: 'setInitialContext',\r\n    value: function setInitialContext() {\r\n      this.vocabulary = null;\r\n      // By default, the prefixes are terms are loaded to the RDFa 1.1. standard within the graph constructor\r\n      this.langAttributes = [{\r\n        namespaceURI: 'http://www.w3.org/XML/1998/namespace',\r\n        localName: 'lang'\r\n      }];\r\n    }\r\n  }, {\r\n    key: 'setXHTMLContext',\r\n    value: function setXHTMLContext() {\r\n      this.setInitialContext();\r\n      this.inXHTMLMode = true;\r\n      this.inHTMLMode = false;\r\n      this.langAttributes = [{\r\n        namespaceURI: 'http://www.w3.org/XML/1998/namespace',\r\n        localName: 'lang' }, { namespaceURI: null, localName: 'lang' }];\r\n      // From http://www.w3.org/2011/rdfa-context/xhtml-rdfa-1.1\r\n      this.target.graph.terms['alternate'] = 'http://www.w3.org/1999/xhtml/vocab#alternate';\r\n      this.target.graph.terms['appendix'] = 'http://www.w3.org/1999/xhtml/vocab#appendix';\r\n      this.target.graph.terms['bookmark'] = 'http://www.w3.org/1999/xhtml/vocab#bookmark';\r\n      this.target.graph.terms['cite'] = 'http://www.w3.org/1999/xhtml/vocab#cite';\r\n      this.target.graph.terms['chapter'] = 'http://www.w3.org/1999/xhtml/vocab#chapter';\r\n      this.target.graph.terms['contents'] = 'http://www.w3.org/1999/xhtml/vocab#contents';\r\n      this.target.graph.terms['copyright'] = 'http://www.w3.org/1999/xhtml/vocab#copyright';\r\n      this.target.graph.terms['first'] = 'http://www.w3.org/1999/xhtml/vocab#first';\r\n      this.target.graph.terms['glossary'] = 'http://www.w3.org/1999/xhtml/vocab#glossary';\r\n      this.target.graph.terms['help'] = 'http://www.w3.org/1999/xhtml/vocab#help';\r\n      this.target.graph.terms['icon'] = 'http://www.w3.org/1999/xhtml/vocab#icon';\r\n      this.target.graph.terms['index'] = 'http://www.w3.org/1999/xhtml/vocab#index';\r\n      this.target.graph.terms['last'] = 'http://www.w3.org/1999/xhtml/vocab#last';\r\n      this.target.graph.terms['license'] = 'http://www.w3.org/1999/xhtml/vocab#license';\r\n      this.target.graph.terms['meta'] = 'http://www.w3.org/1999/xhtml/vocab#meta';\r\n      this.target.graph.terms['next'] = 'http://www.w3.org/1999/xhtml/vocab#next';\r\n      this.target.graph.terms['prev'] = 'http://www.w3.org/1999/xhtml/vocab#prev';\r\n      this.target.graph.terms['previous'] = 'http://www.w3.org/1999/xhtml/vocab#previous';\r\n      this.target.graph.terms['section'] = 'http://www.w3.org/1999/xhtml/vocab#section';\r\n      this.target.graph.terms['stylesheet'] = 'http://www.w3.org/1999/xhtml/vocab#stylesheet';\r\n      this.target.graph.terms['subsection'] = 'http://www.w3.org/1999/xhtml/vocab#subsection';\r\n      this.target.graph.terms['start'] = 'http://www.w3.org/1999/xhtml/vocab#start';\r\n      this.target.graph.terms['top'] = 'http://www.w3.org/1999/xhtml/vocab#top';\r\n      this.target.graph.terms['up'] = 'http://www.w3.org/1999/xhtml/vocab#up';\r\n      this.target.graph.terms['p3pv1'] = 'http://www.w3.org/1999/xhtml/vocab#p3pv1';\r\n      // other\r\n      this.target.graph.terms['related'] = 'http://www.w3.org/1999/xhtml/vocab#related';\r\n      this.target.graph.terms['role'] = 'http://www.w3.org/1999/xhtml/vocab#role';\r\n      this.target.graph.terms['transformation'] = 'http://www.w3.org/1999/xhtml/vocab#transformation';\r\n    }\r\n  }, {\r\n    key: 'setXMLContext',\r\n    value: function setXMLContext() {\r\n      this.setInitialContext();\r\n      this.inXHTMLMode = false;\r\n      this.inHTMLMode = false;\r\n    }\r\n  }, {\r\n    key: 'tokenize',\r\n    value: function tokenize(str) {\r\n      return this.trim(str).split(/\\s+/);\r\n    }\r\n  }, {\r\n    key: 'toRDFNodeObject',\r\n    value: function toRDFNodeObject(x) {\r\n      if (typeof x === 'undefined') return undefined;\r\n      if (typeof x === 'string') {\r\n        if (x.substring(0, 2) === '_:') {\r\n          if (typeof this.blankNodes[x.substring(2)] === 'undefined') {\r\n            this.blankNodes[x.substring(2)] = new BlankNode(x.substring(2));\r\n          }\r\n          return this.blankNodes[x.substring(2)];\r\n        }\r\n        return rdf.namedNode(x);\r\n      }\r\n      switch (x.type) {\r\n        case RDFaProcessor.objectURI:\r\n          if (x.value.substring(0, 2) === '_:') {\r\n            if (typeof this.blankNodes[x.value.substring(2)] === 'undefined') {\r\n              this.blankNodes[x.value.substring(2)] = new BlankNode(x.value.substring(2));\r\n            }\r\n            return this.blankNodes[x.value.substring(2)];\r\n          }\r\n          return rdf.namedNode(x.value);\r\n        case RDFaProcessor.PlainLiteralURI:\r\n          return new Literal(x.value, x.language || '');\r\n        case RDFaProcessor.XMLLiteralURI:\r\n        case RDFaProcessor.HTMLLiteralURI:\r\n          var string = '';\r\n          Object.keys(x.value).forEach(function (i) {\r\n            string += Util.domToString(x.value[i], this.htmlOptions);\r\n          });\r\n          return new Literal(string, '', new NamedNode(x.type));\r\n        default:\r\n          return new Literal(x.value, '', new NamedNode(x.type));\r\n      }\r\n    }\r\n  }, {\r\n    key: 'trim',\r\n    value: function trim(str) {\r\n      return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\r\n    }\r\n  }], [{\r\n    key: 'parseRDFaDOM',\r\n    value: function parseRDFaDOM(dom, kb, base) {\r\n      var p = new RDFaProcessor(kb, { 'base': base });\r\n      //dom.baseURI = base;\r\n      p.process(dom);\r\n    }\r\n  }]);\r\n\r\n  return RDFaProcessor;\r\n}();\r\n\r\nRDFaProcessor.XMLLiteralURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral';\r\nRDFaProcessor.HTMLLiteralURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#HTML';\r\nRDFaProcessor.PlainLiteralURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral';\r\nRDFaProcessor.objectURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#object';\r\nRDFaProcessor.typeURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type';\r\nRDFaProcessor.nameChar = '[-A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u10000-\\uEFFFF.0-9\\xB7\\u0300-\\u036F\\u203F-\\u2040]';\r\nRDFaProcessor.nameStartChar = '[A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\xFF\\u0100-\\u0131\\u0134-\\u013E\\u0141-\\u0148\\u014A-\\u017E\\u0180-\\u01C3\\u01CD-\\u01F0\\u01F4-\\u01F5\\u01FA-\\u0217\\u0250-\\u02A8\\u02BB-\\u02C1\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03CE\\u03D0-\\u03D6\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2-\\u03F3\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E-\\u0481\\u0490-\\u04C4\\u04C7-\\u04C8\\u04CB-\\u04CC\\u04D0-\\u04EB\\u04EE-\\u04F5\\u04F8-\\u04F9\\u0531-\\u0556\\u0559\\u0561-\\u0586\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u063A\\u0641-\\u064A\\u0671-\\u06B7\\u06BA-\\u06BE\\u06C0-\\u06CE\\u06D0-\\u06D3\\u06D5\\u06E5-\\u06E6\\u0905-\\u0939\\u093D\\u0958-\\u0961\\u0985-\\u098C\\u098F-\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09DC-\\u09DD\\u09DF-\\u09E1\\u09F0-\\u09F1\\u0A05-\\u0A0A\\u0A0F-\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32-\\u0A33\\u0A35-\\u0A36\\u0A38-\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8B\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2-\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AE0\\u0B05-\\u0B0C\\u0B0F-\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32-\\u0B33\\u0B36-\\u0B39\\u0B3D\\u0B5C-\\u0B5D\\u0B5F-\\u0B61\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99-\\u0B9A\\u0B9C\\u0B9E-\\u0B9F\\u0BA3-\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB5\\u0BB7-\\u0BB9\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C60-\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CDE\\u0CE0-\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D60-\\u0D61\\u0E01-\\u0E2E\\u0E30\\u0E32-\\u0E33\\u0E40-\\u0E45\\u0E81-\\u0E82\\u0E84\\u0E87-\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA-\\u0EAB\\u0EAD-\\u0EAE\\u0EB0\\u0EB2-\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0F40-\\u0F47\\u0F49-\\u0F69\\u10A0-\\u10C5\\u10D0-\\u10F6\\u1100\\u1102-\\u1103\\u1105-\\u1107\\u1109\\u110B-\\u110C\\u110E-\\u1112\\u113C\\u113E\\u1140\\u114C\\u114E\\u1150\\u1154-\\u1155\\u1159\\u115F-\\u1161\\u1163\\u1165\\u1167\\u1169\\u116D-\\u116E\\u1172-\\u1173\\u1175\\u119E\\u11A8\\u11AB\\u11AE-\\u11AF\\u11B7-\\u11B8\\u11BA\\u11BC-\\u11C2\\u11EB\\u11F0\\u11F9\\u1E00-\\u1E9B\\u1EA0-\\u1EF9\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2126\\u212A-\\u212B\\u212E\\u2180-\\u2182\\u3041-\\u3094\\u30A1-\\u30FA\\u3105-\\u312C\\uAC00-\\uD7A3\\u4E00-\\u9FA5\\u3007\\u3021-\\u3029_]';\r\nRDFaProcessor.NCNAME = new RegExp('^' + RDFaProcessor.nameStartChar + RDFaProcessor.nameChar + '*$');\r\n\r\n/*\r\nRDFaProcessor.prototype.resolveAndNormalize = function(base,href) {\r\n   var u = base.resolve(href)\r\n   var parsed = this.parseURI(u)\r\n   parsed.normalize()\r\n   return parsed.spec\r\n}\r\n*/\r\n\r\nRDFaProcessor.dateTimeTypes = [{ pattern: /-?P(?:[0-9]+Y)?(?:[0-9]+M)?(?:[0-9]+D)?(?:T(?:[0-9]+H)?(?:[0-9]+M)?(?:[0-9]+(?:\\.[0-9]+)?S)?)?/,\r\n  type: 'http://www.w3.org/2001/XMLSchema#duration' }, { pattern: /-?(?:[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|00[1-9][0-9]|000[1-9])-[0-9][0-9]-[0-9][0-9]T(?:[0-1][0-9]|2[0-4]):[0-5][0-9]:[0-5][0-9](?:\\.[0-9]+)?(?:Z|[+\\-][0-9][0-9]:[0-9][0-9])?/,\r\n  type: 'http://www.w3.org/2001/XMLSchema#dateTime' }, { pattern: /-?(?:[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|00[1-9][0-9]|000[1-9])-[0-9][0-9]-[0-9][0-9](?:Z|[+\\-][0-9][0-9]:[0-9][0-9])?/,\r\n  type: 'http://www.w3.org/2001/XMLSchema#date' }, { pattern: /(?:[0-1][0-9]|2[0-4]):[0-5][0-9]:[0-5][0-9](?:\\.[0-9]+)?(?:Z|[+\\-][0-9][0-9]:[0-9][0-9])?/,\r\n  type: 'http://www.w3.org/2001/XMLSchema#time' }, { pattern: /-?(?:[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|00[1-9][0-9]|000[1-9])-[0-9][0-9]/,\r\n  type: 'http://www.w3.org/2001/XMLSchema#gYearMonth' }, { pattern: /-?[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|00[1-9][0-9]|000[1-9]/,\r\n  type: 'http://www.w3.org/2001/XMLSchema#gYear' }];\r\n\r\nmodule.exports = RDFaProcessor;\n\n\n// WEBPACK FOOTER //\n// ./node_modules/rdfgraphnode/js/rdfa-processor-dirty-hack.js","/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false Mustache: true*/\n\n(function defineMustache (global, factory) {\n  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {\n    factory(exports); // CommonJS\n  } else if (typeof define === 'function' && define.amd) {\n    define(['exports'], factory); // AMD\n  } else {\n    global.Mustache = {};\n    factory(global.Mustache); // script, wsh, asp\n  }\n}(this, function mustacheFactory (mustache) {\n\n  var objectToString = Object.prototype.toString;\n  var isArray = Array.isArray || function isArrayPolyfill (object) {\n    return objectToString.call(object) === '[object Array]';\n  };\n\n  function isFunction (object) {\n    return typeof object === 'function';\n  }\n\n  /**\n   * More correct typeof string handling array\n   * which normally returns typeof 'object'\n   */\n  function typeStr (obj) {\n    return isArray(obj) ? 'array' : typeof obj;\n  }\n\n  function escapeRegExp (string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n  }\n\n  /**\n   * Null safe way of checking whether or not an object,\n   * including its prototype, has a given property\n   */\n  function hasProperty (obj, propName) {\n    return obj != null && typeof obj === 'object' && (propName in obj);\n  }\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  var regExpTest = RegExp.prototype.test;\n  function testRegExp (re, string) {\n    return regExpTest.call(re, string);\n  }\n\n  var nonSpaceRe = /\\S/;\n  function isWhitespace (string) {\n    return !testRegExp(nonSpaceRe, string);\n  }\n\n  var entityMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n  };\n\n  function escapeHtml (string) {\n    return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap (s) {\n      return entityMap[s];\n    });\n  }\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var equalsRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  /**\n   * Breaks up the given `template` string into a tree of tokens. If the `tags`\n   * argument is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n   * course, the default is to use mustaches (i.e. mustache.tags).\n   *\n   * A token is an array with at least 4 elements. The first element is the\n   * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n   * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n   * all text that appears outside a symbol this element is \"text\".\n   *\n   * The second element of a token is its \"value\". For mustache tags this is\n   * whatever else was inside the tag besides the opening symbol. For text tokens\n   * this is the text itself.\n   *\n   * The third and fourth elements of the token are the start and end indices,\n   * respectively, of the token in the original template.\n   *\n   * Tokens that are the root node of a subtree contain two more elements: 1) an\n   * array of tokens in the subtree and 2) the index in the original template at\n   * which the closing tag for that section begins.\n   */\n  function parseTemplate (template, tags) {\n    if (!template)\n      return [];\n\n    var sections = [];     // Stack to hold section tokens\n    var tokens = [];       // Buffer to hold the tokens\n    var spaces = [];       // Indices of whitespace tokens on the current line\n    var hasTag = false;    // Is there a {{tag}} on the current line?\n    var nonSpace = false;  // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace () {\n      if (hasTag && !nonSpace) {\n        while (spaces.length)\n          delete tokens[spaces.pop()];\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var openingTagRe, closingTagRe, closingCurlyRe;\n    function compileTags (tagsToCompile) {\n      if (typeof tagsToCompile === 'string')\n        tagsToCompile = tagsToCompile.split(spaceRe, 2);\n\n      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\n        throw new Error('Invalid tags: ' + tagsToCompile);\n\n      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\n      closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\n      closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\n    }\n\n    compileTags(tags || mustache.tags);\n\n    var scanner = new Scanner(template);\n\n    var start, type, value, chr, token, openSection;\n    while (!scanner.eos()) {\n      start = scanner.pos;\n\n      // Match any text between tags.\n      value = scanner.scanUntil(openingTagRe);\n\n      if (value) {\n        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push([ 'text', chr, start, start + 1 ]);\n          start += 1;\n\n          // Check for whitespace on the current line.\n          if (chr === '\\n')\n            stripSpace();\n        }\n      }\n\n      // Match the opening tag.\n      if (!scanner.scan(openingTagRe))\n        break;\n\n      hasTag = true;\n\n      // Get the tag type.\n      type = scanner.scan(tagRe) || 'name';\n      scanner.scan(whiteRe);\n\n      // Get the tag value.\n      if (type === '=') {\n        value = scanner.scanUntil(equalsRe);\n        scanner.scan(equalsRe);\n        scanner.scanUntil(closingTagRe);\n      } else if (type === '{') {\n        value = scanner.scanUntil(closingCurlyRe);\n        scanner.scan(curlyRe);\n        scanner.scanUntil(closingTagRe);\n        type = '&';\n      } else {\n        value = scanner.scanUntil(closingTagRe);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(closingTagRe))\n        throw new Error('Unclosed tag at ' + scanner.pos);\n\n      token = [ type, value, start, scanner.pos ];\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === '/') {\n        // Check section nesting.\n        openSection = sections.pop();\n\n        if (!openSection)\n          throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n        if (openSection[1] !== value)\n          throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n      } else if (type === 'name' || type === '{' || type === '&') {\n        nonSpace = true;\n      } else if (type === '=') {\n        // Set the tags for the next time around.\n        compileTags(value);\n      }\n    }\n\n    // Make sure there are no open sections when we're done.\n    openSection = sections.pop();\n\n    if (openSection)\n      throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n    return nestTokens(squashTokens(tokens));\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens (tokens) {\n    var squashedTokens = [];\n\n    var token, lastToken;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      if (token) {\n        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n          lastToken[1] += token[1];\n          lastToken[3] = token[3];\n        } else {\n          squashedTokens.push(token);\n          lastToken = token;\n        }\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n  function nestTokens (tokens) {\n    var nestedTokens = [];\n    var collector = nestedTokens;\n    var sections = [];\n\n    var token, section;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n        case '#':\n        case '^':\n          collector.push(token);\n          sections.push(token);\n          collector = token[4] = [];\n          break;\n        case '/':\n          section = sections.pop();\n          section[5] = token[2];\n          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n          break;\n        default:\n          collector.push(token);\n      }\n    }\n\n    return nestedTokens;\n  }\n\n  /**\n   * A simple string scanner that is used by the template parser to find\n   * tokens in template strings.\n   */\n  function Scanner (string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function eos () {\n    return this.tail === '';\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function scan (re) {\n    var match = this.tail.match(re);\n\n    if (!match || match.index !== 0)\n      return '';\n\n    var string = match[0];\n\n    this.tail = this.tail.substring(string.length);\n    this.pos += string.length;\n\n    return string;\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function scanUntil (re) {\n    var index = this.tail.search(re), match;\n\n    switch (index) {\n      case -1:\n        match = this.tail;\n        this.tail = '';\n        break;\n      case 0:\n        match = '';\n        break;\n      default:\n        match = this.tail.substring(0, index);\n        this.tail = this.tail.substring(index);\n    }\n\n    this.pos += match.length;\n\n    return match;\n  };\n\n  /**\n   * Represents a rendering context by wrapping a view object and\n   * maintaining a reference to the parent context.\n   */\n  function Context (view, parentContext) {\n    this.view = view;\n    this.cache = { '.': this.view };\n    this.parent = parentContext;\n  }\n\n  /**\n   * Creates a new context using the given view with this context\n   * as the parent.\n   */\n  Context.prototype.push = function push (view) {\n    return new Context(view, this);\n  };\n\n  /**\n   * Returns the value of the given name in this context, traversing\n   * up the context hierarchy if the value is absent in this context's view.\n   */\n  Context.prototype.lookup = function lookup (name) {\n    var cache = this.cache;\n\n    var value;\n    if (cache.hasOwnProperty(name)) {\n      value = cache[name];\n    } else {\n      var context = this, names, index, lookupHit = false;\n\n      while (context) {\n        if (name.indexOf('.') > 0) {\n          value = context.view;\n          names = name.split('.');\n          index = 0;\n\n          /**\n           * Using the dot notion path in `name`, we descend through the\n           * nested objects.\n           *\n           * To be certain that the lookup has been successful, we have to\n           * check if the last object in the path actually has the property\n           * we are looking for. We store the result in `lookupHit`.\n           *\n           * This is specially necessary for when the value has been set to\n           * `undefined` and we want to avoid looking up parent contexts.\n           **/\n          while (value != null && index < names.length) {\n            if (index === names.length - 1)\n              lookupHit = hasProperty(value, names[index]);\n\n            value = value[names[index++]];\n          }\n        } else {\n          value = context.view[name];\n          lookupHit = hasProperty(context.view, name);\n        }\n\n        if (lookupHit)\n          break;\n\n        context = context.parent;\n      }\n\n      cache[name] = value;\n    }\n\n    if (isFunction(value))\n      value = value.call(this.view);\n\n    return value;\n  };\n\n  /**\n   * A Writer knows how to take a stream of tokens and render them to a\n   * string, given a context. It also maintains a cache of templates to\n   * avoid the need to parse the same template twice.\n   */\n  function Writer () {\n    this.cache = {};\n  }\n\n  /**\n   * Clears all cached templates in this writer.\n   */\n  Writer.prototype.clearCache = function clearCache () {\n    this.cache = {};\n  };\n\n  /**\n   * Parses and caches the given `template` and returns the array of tokens\n   * that is generated from the parse.\n   */\n  Writer.prototype.parse = function parse (template, tags) {\n    var cache = this.cache;\n    var tokens = cache[template];\n\n    if (tokens == null)\n      tokens = cache[template] = parseTemplate(template, tags);\n\n    return tokens;\n  };\n\n  /**\n   * High-level method that is used to render the given `template` with\n   * the given `view`.\n   *\n   * The optional `partials` argument may be an object that contains the\n   * names and templates of partials that are used in the template. It may\n   * also be a function that is used to load partial templates on the fly\n   * that takes a single argument: the name of the partial.\n   */\n  Writer.prototype.render = function render (template, view, partials) {\n    var tokens = this.parse(template);\n    var context = (view instanceof Context) ? view : new Context(view);\n    return this.renderTokens(tokens, context, partials, template);\n  };\n\n  /**\n   * Low-level method that renders the given array of `tokens` using\n   * the given `context` and `partials`.\n   *\n   * Note: The `originalTemplate` is only ever used to extract the portion\n   * of the original template that was contained in a higher-order section.\n   * If the template doesn't use higher-order sections, this argument may\n   * be omitted.\n   */\n  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate) {\n    var buffer = '';\n\n    var token, symbol, value;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      value = undefined;\n      token = tokens[i];\n      symbol = token[0];\n\n      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);\n      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);\n      else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);\n      else if (symbol === '&') value = this.unescapedValue(token, context);\n      else if (symbol === 'name') value = this.escapedValue(token, context);\n      else if (symbol === 'text') value = this.rawValue(token);\n\n      if (value !== undefined)\n        buffer += value;\n    }\n\n    return buffer;\n  };\n\n  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {\n    var self = this;\n    var buffer = '';\n    var value = context.lookup(token[1]);\n\n    // This function is used to render an arbitrary template\n    // in the current context by higher-order sections.\n    function subRender (template) {\n      return self.render(template, context, partials);\n    }\n\n    if (!value) return;\n\n    if (isArray(value)) {\n      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);\n      }\n    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);\n    } else if (isFunction(value)) {\n      if (typeof originalTemplate !== 'string')\n        throw new Error('Cannot use higher-order sections without the original template');\n\n      // Extract the portion of the original template that the section contains.\n      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n      if (value != null)\n        buffer += value;\n    } else {\n      buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n    }\n    return buffer;\n  };\n\n  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {\n    var value = context.lookup(token[1]);\n\n    // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n    if (!value || (isArray(value) && value.length === 0))\n      return this.renderTokens(token[4], context, partials, originalTemplate);\n  };\n\n  Writer.prototype.renderPartial = function renderPartial (token, context, partials) {\n    if (!partials) return;\n\n    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n    if (value != null)\n      return this.renderTokens(this.parse(value), context, partials, value);\n  };\n\n  Writer.prototype.unescapedValue = function unescapedValue (token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null)\n      return value;\n  };\n\n  Writer.prototype.escapedValue = function escapedValue (token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null)\n      return mustache.escape(value);\n  };\n\n  Writer.prototype.rawValue = function rawValue (token) {\n    return token[1];\n  };\n\n  mustache.name = 'mustache.js';\n  mustache.version = '2.3.0';\n  mustache.tags = [ '{{', '}}' ];\n\n  // All high-level mustache.* functions use this writer.\n  var defaultWriter = new Writer();\n\n  /**\n   * Clears all cached templates in the default writer.\n   */\n  mustache.clearCache = function clearCache () {\n    return defaultWriter.clearCache();\n  };\n\n  /**\n   * Parses and caches the given template in the default writer and returns the\n   * array of tokens it contains. Doing this ahead of time avoids the need to\n   * parse templates on the fly as they are rendered.\n   */\n  mustache.parse = function parse (template, tags) {\n    return defaultWriter.parse(template, tags);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n  mustache.render = function render (template, view, partials) {\n    if (typeof template !== 'string') {\n      throw new TypeError('Invalid template! Template should be a \"string\" ' +\n                          'but \"' + typeStr(template) + '\" was given as the first ' +\n                          'argument for mustache#render(template, view, partials)');\n    }\n\n    return defaultWriter.render(template, view, partials);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.,\n  /*eslint-disable */ // eslint wants camel cased function name\n  mustache.to_html = function to_html (template, view, partials, send) {\n    /*eslint-enable*/\n\n    var result = mustache.render(template, view, partials);\n\n    if (isFunction(send)) {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  mustache.escape = escapeHtml;\n\n  // Export these mainly for testing, but also for advanced usage.\n  mustache.Scanner = Scanner;\n  mustache.Context = Context;\n  mustache.Writer = Writer;\n\n  return mustache;\n}));\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/mustache/mustache.js","var $rdf = require(\"rdflib\");\n\nmodule.exports = {\n    schema: function (suffix) {\n        return $rdf.sym(\"http://schema.org/\" + suffix);\n    },\n    rdf: function (suffix) {\n        return $rdf.sym(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" + suffix);\n    },\n    rdfs: function (suffix) {\n        return $rdf.sym(\"http://www.w3.org/2000/01/rdf-schema#\" + suffix);\n    },\n    foaf: function (suffix) {\n        return $rdf.sym(\"http://xmlns.com/foaf/0.1/\" + suffix);\n    },\n    rdf2h: function(suffix) {\n        return $rdf.sym(\"http://rdf2h.github.io/2015/rdf2h#\"+suffix);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/vocab.js"],"sourceRoot":""}